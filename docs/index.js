/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../formality-core/examples/_export_to_webpack_.js":
/*!*********************************************************!*\
  !*** ../formality-core/examples/_export_to_webpack_.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var array   = __webpack_require__(/*! ./array.fmc */ \"../formality-core/examples/array.fmc\").default;\nvar bits    = __webpack_require__(/*! ./bits.fmc */ \"../formality-core/examples/bits.fmc\").default;\nvar bool    = __webpack_require__(/*! ./bool.fmc */ \"../formality-core/examples/bool.fmc\").default;\nvar hash    = __webpack_require__(/*! ./hash.fmc */ \"../formality-core/examples/hash.fmc\").default;\nvar kaelin  = __webpack_require__(/*! ./kaelin.fmc */ \"../formality-core/examples/kaelin.fmc\").default;\nvar list    = __webpack_require__(/*! ./list.fmc */ \"../formality-core/examples/list.fmc\").default;\nvar main    = __webpack_require__(/*! ./main.fmc */ \"../formality-core/examples/main.fmc\").default;\nvar maybe   = __webpack_require__(/*! ./maybe.fmc */ \"../formality-core/examples/maybe.fmc\").default;\nvar nat     = __webpack_require__(/*! ./nat.fmc */ \"../formality-core/examples/nat.fmc\").default;\nvar num     = __webpack_require__(/*! ./num.fmc */ \"../formality-core/examples/num.fmc\").default;\nvar package = __webpack_require__(/*! ./package.json */ \"../formality-core/examples/package.json\").default;\nvar pair    = __webpack_require__(/*! ./pair.fmc */ \"../formality-core/examples/pair.fmc\").default;\nvar string  = __webpack_require__(/*! ./string.fmc */ \"../formality-core/examples/string.fmc\").default;\nvar term    = __webpack_require__(/*! ./term.fmc */ \"../formality-core/examples/term.fmc\").default;\nvar tree    = __webpack_require__(/*! ./tree.fmc */ \"../formality-core/examples/tree.fmc\").default;\nvar tuple   = __webpack_require__(/*! ./tuple.fmc */ \"../formality-core/examples/tuple.fmc\").default;\nvar vector2 = __webpack_require__(/*! ./vector2.fmc */ \"../formality-core/examples/vector2.fmc\").default;\n\nmodule.exports = [\n  array,\n  bits,\n  bool,\n  hash,\n  kaelin,\n  list,\n  main,\n  maybe,\n  nat,\n  num,\n  package,\n  pair,\n  string,\n  term,\n  tree,\n  tuple,\n  vector2,\n].join(\"\\n\");\n\n\n\n//# sourceURL=webpack:///../formality-core/examples/_export_to_webpack_.js?");

/***/ }),

/***/ "../formality-core/examples/array.fmc":
/*!********************************************!*\
  !*** ../formality-core/examples/array.fmc ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Efficient \\\"C-like\\\" arrays using perfect binary trees\\n\\n// Example usage of this library\\ndef array_example:\\n\\n  // Creates function to allocate an arrays of 65536 (2^16) elements\\n  let dpt  = ~16\\n  dup init = (init dpt)\\n\\n  // Allocates a new array and creates its methods\\n  # dup arr    = (init ##0)   // ~133k graph-rewrites to alloc 65536 zeros\\n    dup write  = (write dpt)  // ~650 graph-rewrites per write with dpt=16\\n    dup update = (update dpt) // ~650 graph-rewrites per update with dpt=16\\n    dup read   = (read dpt)   // ~650 graph-rewrites per read with dpt=16\\n\\n  // Performs some writes and reads\\n  # let add      = boxed_add\\n    let arr      = (write 0 #10 arr)       // arr[0] = 10\\n    let arr      = (write 1 #12 arr)       // arr[1] = 12\\n    let arr      = (update 2 (add #8) arr) // arr[2] += 8\\n    let arr      = (write 3 #7 arr)        // arr[1] = 12\\n    get [arr, a] = (read 0 arr)            // a = arr[0]\\n    get [arr, b] = (read 1 arr)            // b = arr[1]\\n    get [arr, c] = (read 2 arr)            // c = arr[2]\\n    get [arr, d] = (read 3 arr)            // c = arr[2]\\n    [\\\"arr[0] + arr[1] + arr[2]:\\\", (add (add a b) c)]\\n\\n// Example of folding over an array\\ndef fold_array_example:\\n  let array = [[[1,2],[3,4]],[[5,6],[7,8]]]\\n  let node  = {a b} |a + b|\\n  let leaf  = {x} |x * 2|\\n  dup fold  = (fold_array ~3)\\n  # (fold #array #node #leaf)\\n\\n// with\\n// | Searches an element, updates it, returns the updated\\n// | array and a value that can depend on the element\\n// : {-A  : Type}             -- Type of the elements\\n//   {dpt : CNat}             -- Length of array = 2^dpt\\n//   ! {path : Num}           -- Num storing path to element\\n//     {fn   : {x : A} (A,A)} -- Receives found element, returns an element to replace it by, and a return value.\\n//     {(Array dpt A)}        -- The array to be queried\\n//     ((Array dpt A), A)     -- The updated array, and return value returned by `fn`.\\ndef with: {dpt}\\n  let init = {path fn} fn\\n  let loop = {cont path fn}\\n    cpy path = path\\n    get [swap0,swap1] =\\n      if |path % 2|\\n      then: [{x}x, {x}x]\\n      else: [swap, swap]\\n    (cont |path / 2| {arr}\\n      get [a,b] = (swap0 arr)\\n      get [b,x] = (fn b)\\n      [(swap1 [a,b]), x])\\n  let stop = {func} func\\n  dup fold = (for dpt #init #loop #stop)\\n  # {path fn arr} (fold path fn arr)\\n\\n// update\\n// | Applies a function to an element\\n// : {-A  : Type}             -- Type of the elements\\n//   {dpt : CNat}             -- Length of array = 2^dpt\\n//   ! {path : Num}           -- Num storing path to element\\n//     {fn   : {x : A} A}     -- Update function\\n//     {arr  : (Array dpt A)} -- The array to be updated\\n//     (Array dpt A)          -- The updated array, and return value returned by `fn`.\\ndef update: {dpt}\\n  dup with = (with dpt) \\n  # {path f arr} (fst (with path {x}[(f x), 0] arr))\\n\\n// read\\n// | Returns a copy of an element and returns the array unchanged\\n// : {-A  : Type}              -- Type of the elements\\n//   {dpt : CNat}              -- Length of array = 2^dpt\\n//   ! {path : Num}            -- Num storing path to element\\n//     {arr  : (Array dpt !A)} -- The array to be read\\n//     {(Array dpt !A),!A}    -- The array itself, and a copy of the element\\ndef read: {dpt}\\n  dup with = (with dpt)\\n  # {path arr}\\n    let f = {x}\\n      dup x = x\\n      [#x, #x]\\n    (with path f arr)\\n\\n// take\\n// | Takes an element out of an array and returns it\\n// : {-A  : Type}             -- Type of the elements\\n//   {dpt : CNat}             -- Length of array = 2^dpt\\n//   ! {path : Num}           -- Num storing path to element\\n//     {val  : A}             -- New value to put in place of old\\n//     {arr  : (Array dpt A)} -- The array to be taken\\n//     {(Array dpt A),A}      -- The updated array and the take element\\ndef take: {dpt}\\n  dup with = (with dpt)\\n  # {path val arr}\\n    (with path {x}[val,x] arr)\\n\\n// write\\n// | Overwrites an element of the array\\n// : {-A  : Type}             -- Type of hte elements\\n//   {dpt : CNat}             -- Length of the array = 2^dpt\\n//   ! {path : Num}           -- Num storing path to element\\n//     {arr  : (Array dpt A)} -- Array to be written\\n//     {val  : A}             -- Value to be written\\n//     (Array dpt A)          -- The overwritten array\\ndef write: {dpt}\\n  dup update = (update dpt)\\n  # {path val} (update path {x}val)\\n\\n// init\\n// | Generates an array with 2^dpt copies of val\\n// : {-A  : Type}\\n//   {dpt : CNat}\\n//   ! {val : !A}\\n//   ! (Array dpt A)\\ndef init: {dpt}\\n  let loop = {arr}\\n    dup arr = arr\\n    # [arr, arr]\\n  dup fold = (dpt #loop)\\n  # {init} (fold init)\\n\\n// gen\\n// | Generates an array by mapping a function to each index\\n// : {-A  : Type}\\n//   {dpt : CNat}\\n//   ! {fun : !{idx : !Num} A}\\n//   ! (Array dpt !A)\\ndef gen: {dpt}\\n  let init = {fun}\\n    dup fun = fun\\n    # {idx} (fun idx)\\n  let loop = {arr fun}\\n    dup arr = (arr fun)\\n    # {idx}\\n      dup idx = idx\\n      let lft = (arr #||idx * 2| + 0|)\\n      let rgt = (arr #||idx * 2| + 1|)\\n      [lft, rgt]\\n  let stop = {arr fun}\\n    dup arr = (arr fun)\\n    # (arr #0)\\n  (for dpt #init #loop #stop)\\n\\n// range\\n// | Generates an array with all numbers from 0 to 2^dpt\\n// : {dpt : CNat}\\n//   !!(Array dpt !Num)\\ndef range: {dpt}\\n  dup gen = (gen dpt)\\n  # (gen #{x}x)\\n\\n// fold_array\\n// : {-A : Type}\\n//   {dpt : Nat}\\n//   ! {arr  : !(Array dpt A)}\\n//     {-P   : Type}\\n//     {Node : !{lft : A} {rgt : A} P}\\n//     {Leaf : !{val : A} P}\\n//     ! P\\ndef fold_array: {dpt}\\n  let init = {Node Leaf}\\n    dup Node = Node\\n    dup Leaf = Leaf\\n    # {val} (Leaf val)\\n  let loop = {rec Node Leaf}\\n    dup Node = Node\\n    dup Leaf = Leaf\\n    dup rec  = (rec #Node #Leaf)\\n    # {arr}\\n      get [lft,rgt] = arr\\n      let lft = (rec lft)\\n      let rgt = (rec rgt)\\n      (Node lft rgt)\\n  dup fold = (dpt #loop)\\n  # {arr Node Leaf}\\n    dup arr  = arr\\n    dup Node = Node\\n    dup Leaf = Leaf\\n    dup fold = (fold init #Node #Leaf)\\n    # (fold arr)\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/array.fmc?");

/***/ }),

/***/ "../formality-core/examples/bits.fmc":
/*!*******************************************!*\
  !*** ../formality-core/examples/bits.fmc ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def o: {bs o i e} (o bs)\\ndef i: {bs o i e} (i bs)\\ndef e:    {o i e} e\\n\\ndef inc_cont: {bs cont}\\n  {o i e}\\n  let case_o = i\\n  let case_i = {x} (o (cont x))\\n  let case_e = e\\n  (bs case_o case_i case_e) \\n\\ndef inc: {n}\\n  let case_s = # {cont bs} (inc_cont bs cont)\\n  let case_z = {bs} bs\\n  dup S = (n case_s)\\n  # (S case_z)\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/bits.fmc?");

/***/ }),

/***/ "../formality-core/examples/bool.fmc":
/*!*******************************************!*\
  !*** ../formality-core/examples/bool.fmc ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// ::::::::::\\n// :: Bool ::\\n// ::::::::::\\n\\ndef true:\\n  {t f} t\\n\\ndef false:\\n  {t f} f\\n\\ndef not: {b}\\n  {t f} (b f t)\\n\\ndef eql: {a b}\\n  (a {x}x not b)\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/bool.fmc?");

/***/ }),

/***/ "../formality-core/examples/hash.fmc":
/*!*******************************************!*\
  !*** ../formality-core/examples/hash.fmc ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def keccak.f_loop: {arr} {t}\\n  (arr {n\\n    a00 a01 a02 a03 a04 a05 a06 a07 a08 a09\\n    a10 a11 a12 a13 a14 a15 a16 a17 a18 a19\\n    a20 a21 a22 a23 a24 a25 a26 a27 a28 a29\\n    a30 a31 a32 a33 a34 a35 a36 a37 a38 a39\\n    a40 a41 a42 a43 a44 a45 a46 a47 a48 a49}\\n\\n    cpy n   = n\\n    cpy a00 = a00\\n    cpy a01 = a01\\n    cpy a02 = a02\\n    cpy a03 = a03\\n    cpy a04 = a04\\n    cpy a05 = a05\\n    cpy a06 = a06\\n    cpy a07 = a07\\n    cpy a08 = a08\\n    cpy a09 = a09\\n    cpy a10 = a10\\n    cpy a11 = a11\\n    cpy a12 = a12\\n    cpy a13 = a13\\n    cpy a14 = a14\\n    cpy a15 = a15\\n    cpy a16 = a16\\n    cpy a17 = a17\\n    cpy a18 = a18\\n    cpy a19 = a19\\n    cpy a20 = a20\\n    cpy a21 = a21\\n    cpy a22 = a22\\n    cpy a23 = a23\\n    cpy a24 = a24\\n    cpy a25 = a25\\n    cpy a26 = a26\\n    cpy a27 = a27\\n    cpy a28 = a28\\n    cpy a29 = a29\\n    cpy a30 = a30\\n    cpy a31 = a31\\n    cpy a32 = a32\\n    cpy a33 = a33\\n    cpy a34 = a34\\n    cpy a35 = a35\\n    cpy a36 = a36\\n    cpy a37 = a37\\n    cpy a38 = a38\\n    cpy a39 = a39\\n    cpy a40 = a40\\n    cpy a41 = a41\\n    cpy a42 = a42\\n    cpy a43 = a43\\n    cpy a44 = a44\\n    cpy a45 = a45\\n    cpy a46 = a46\\n    cpy a47 = a47\\n    cpy a48 = a48\\n    cpy a49 = a49\\n\\n    cpy c0 = ||||a00 ^ a10| ^ a20| ^ a30| ^ a40|\\n    cpy c1 = ||||a01 ^ a11| ^ a21| ^ a31| ^ a41|\\n    cpy c2 = ||||a02 ^ a12| ^ a22| ^ a32| ^ a42|\\n    cpy c3 = ||||a03 ^ a13| ^ a23| ^ a33| ^ a43|\\n    cpy c4 = ||||a04 ^ a14| ^ a24| ^ a34| ^ a44|\\n    cpy c5 = ||||a05 ^ a15| ^ a25| ^ a35| ^ a45|\\n    cpy c6 = ||||a06 ^ a16| ^ a26| ^ a36| ^ a46|\\n    cpy c7 = ||||a07 ^ a17| ^ a27| ^ a37| ^ a47|\\n    cpy c8 = ||||a08 ^ a18| ^ a28| ^ a38| ^ a48|\\n    cpy c9 = ||||a09 ^ a19| ^ a29| ^ a39| ^ a49|\\n\\n    cpy h   = |c8 ^ ||c2 << 1| | |c3 >> 31|||\\n    cpy l   = |c9 ^ ||c3 << 1| | |c2 >> 31|||\\n    cpy a00 = |a00 ^ h|\\n    cpy a01 = |a01 ^ l|\\n    cpy a10 = |a10 ^ h|\\n    cpy a11 = |a11 ^ l|\\n    cpy a20 = |a20 ^ h|\\n    cpy a21 = |a21 ^ l|\\n    cpy a30 = |a30 ^ h|\\n    cpy a31 = |a31 ^ l|\\n    cpy a40 = |a40 ^ h|\\n    cpy a41 = |a41 ^ l|\\n\\n    cpy h   = |c0 ^ ||c4 << 1| | |c5 >> 31|||\\n    cpy l   = |c1 ^ ||c5 << 1| | |c4 >> 31|||\\n    cpy a02 = |a02 ^ h|\\n    cpy a03 = |a03 ^ l|\\n    cpy a12 = |a12 ^ h|\\n    cpy a13 = |a13 ^ l|\\n    cpy a22 = |a22 ^ h|\\n    cpy a23 = |a23 ^ l|\\n    cpy a32 = |a32 ^ h|\\n    cpy a33 = |a33 ^ l|\\n    cpy a42 = |a42 ^ h|\\n    cpy a43 = |a43 ^ l|\\n\\n    cpy h   = |c2 ^ ||c6 << 1| | |c7 >> 31|||\\n    cpy l   = |c3 ^ ||c7 << 1| | |c6 >> 31|||\\n    cpy a04 = |a04 ^ h|\\n    cpy a05 = |a05 ^ l|\\n    cpy a14 = |a14 ^ h|\\n    cpy a15 = |a15 ^ l|\\n    cpy a24 = |a24 ^ h|\\n    cpy a25 = |a25 ^ l|\\n    cpy a34 = |a34 ^ h|\\n    cpy a35 = |a35 ^ l|\\n    cpy a44 = |a44 ^ h|\\n    cpy a45 = |a45 ^ l|\\n\\n    cpy h   = |c4 ^ ||c8 << 1| | |c9 >> 31|||\\n    cpy l   = |c5 ^ ||c9 << 1| | |c8 >> 31|||\\n    cpy a06 = |a06 ^ h|\\n    cpy a07 = |a07 ^ l|\\n    cpy a16 = |a16 ^ h|\\n    cpy a17 = |a17 ^ l|\\n    cpy a26 = |a26 ^ h|\\n    cpy a27 = |a27 ^ l|\\n    cpy a36 = |a36 ^ h|\\n    cpy a37 = |a37 ^ l|\\n    cpy a46 = |a46 ^ h|\\n    cpy a47 = |a47 ^ l|\\n\\n    cpy h   = |c6 ^ ||c0 << 1| | |c1 >> 31|||\\n    cpy l   = |c7 ^ ||c1 << 1| | |c0 >> 31|||\\n    cpy a08 = |a08 ^ h|\\n    cpy a09 = |a09 ^ l|\\n    cpy a18 = |a18 ^ h|\\n    cpy a19 = |a19 ^ l|\\n    cpy a28 = |a28 ^ h|\\n    cpy a29 = |a29 ^ l|\\n    cpy a38 = |a38 ^ h|\\n    cpy a39 = |a39 ^ l|\\n    cpy a48 = |a48 ^ h|\\n    cpy a49 = |a49 ^ l|\\n\\n    cpy b00 = a00\\n    cpy b01 = a01\\n    cpy b32 = ||a11 <<  4| | |a10 >> 28||\\n    cpy b33 = ||a10 <<  4| | |a11 >> 28||\\n    cpy b14 = ||a20 <<  3| | |a21 >> 29||\\n    cpy b15 = ||a21 <<  3| | |a20 >> 29||\\n    cpy b46 = ||a31 <<  9| | |a30 >> 23||\\n    cpy b47 = ||a30 <<  9| | |a31 >> 23||\\n    cpy b28 = ||a40 << 18| | |a41 >> 14||\\n    cpy b29 = ||a41 << 18| | |a40 >> 14||\\n    cpy b20 = ||a02 <<  1| | |a03 >> 31||\\n    cpy b21 = ||a03 <<  1| | |a02 >> 31||\\n    cpy b02 = ||a13 << 12| | |a12 >> 20||\\n    cpy b03 = ||a12 << 12| | |a13 >> 20||\\n    cpy b34 = ||a22 << 10| | |a23 >> 22||\\n    cpy b35 = ||a23 << 10| | |a22 >> 22||\\n    cpy b16 = ||a33 << 13| | |a32 >> 19||\\n    cpy b17 = ||a32 << 13| | |a33 >> 19||\\n    cpy b48 = ||a42 << 02| | |a43 >> 30||\\n    cpy b49 = ||a43 << 02| | |a42 >> 30||\\n    cpy b40 = ||a05 << 30| | |a04 >>  2||\\n    cpy b41 = ||a04 << 30| | |a05 >>  2||\\n    cpy b22 = ||a14 << 06| | |a15 >> 26||\\n    cpy b23 = ||a15 << 06| | |a14 >> 26||\\n    cpy b04 = ||a25 << 11| | |a24 >> 21||\\n    cpy b05 = ||a24 << 11| | |a25 >> 21||\\n    cpy b36 = ||a34 << 15| | |a35 >> 17||\\n    cpy b37 = ||a35 << 15| | |a34 >> 17||\\n    cpy b18 = ||a45 << 29| | |a44 >>  3||\\n    cpy b19 = ||a44 << 29| | |a45 >>  3||\\n    cpy b10 = ||a06 << 28| | |a07 >>  4||\\n    cpy b11 = ||a07 << 28| | |a06 >>  4||\\n    cpy b42 = ||a17 << 23| | |a16 >>  9||\\n    cpy b43 = ||a16 << 23| | |a17 >>  9||\\n    cpy b24 = ||a26 << 25| | |a27 >>  7||\\n    cpy b25 = ||a27 << 25| | |a26 >>  7||\\n    cpy b06 = ||a36 << 21| | |a37 >> 11||\\n    cpy b07 = ||a37 << 21| | |a36 >> 11||\\n    cpy b38 = ||a47 << 24| | |a46 >>  8||\\n    cpy b39 = ||a46 << 24| | |a47 >>  8||\\n    cpy b30 = ||a08 << 27| | |a09 >>  5||\\n    cpy b31 = ||a09 << 27| | |a08 >>  5||\\n    cpy b12 = ||a18 << 20| | |a19 >> 12||\\n    cpy b13 = ||a19 << 20| | |a18 >> 12||\\n    cpy b44 = ||a29 << 07| | |a28 >> 25||\\n    cpy b45 = ||a28 << 07| | |a29 >> 25||\\n    cpy b26 = ||a38 << 08| | |a39 >> 24||\\n    cpy b27 = ||a39 << 08| | |a38 >> 24||\\n    cpy b08 = ||a48 << 14| | |a49 >> 18||\\n    cpy b09 = ||a49 << 14| | |a48 >> 18||\\n\\n    cpy a00 = |b00 ^ ||0 ~ b02| & b04||\\n    cpy a01 = |b01 ^ ||0 ~ b03| & b05||\\n    cpy a10 = |b10 ^ ||0 ~ b12| & b14||\\n    cpy a11 = |b11 ^ ||0 ~ b13| & b15||\\n    cpy a20 = |b20 ^ ||0 ~ b22| & b24||\\n    cpy a21 = |b21 ^ ||0 ~ b23| & b25||\\n    cpy a30 = |b30 ^ ||0 ~ b32| & b34||\\n    cpy a31 = |b31 ^ ||0 ~ b33| & b35||\\n    cpy a40 = |b40 ^ ||0 ~ b42| & b44||\\n    cpy a41 = |b41 ^ ||0 ~ b43| & b45||\\n    cpy a02 = |b02 ^ ||0 ~ b04| & b06||\\n    cpy a03 = |b03 ^ ||0 ~ b05| & b07||\\n    cpy a12 = |b12 ^ ||0 ~ b14| & b16||\\n    cpy a13 = |b13 ^ ||0 ~ b15| & b17||\\n    cpy a22 = |b22 ^ ||0 ~ b24| & b26||\\n    cpy a23 = |b23 ^ ||0 ~ b25| & b27||\\n    cpy a32 = |b32 ^ ||0 ~ b34| & b36||\\n    cpy a33 = |b33 ^ ||0 ~ b35| & b37||\\n    cpy a42 = |b42 ^ ||0 ~ b44| & b46||\\n    cpy a43 = |b43 ^ ||0 ~ b45| & b47||\\n    cpy a04 = |b04 ^ ||0 ~ b06| & b08||\\n    cpy a05 = |b05 ^ ||0 ~ b07| & b09||\\n    cpy a14 = |b14 ^ ||0 ~ b16| & b18||\\n    cpy a15 = |b15 ^ ||0 ~ b17| & b19||\\n    cpy a24 = |b24 ^ ||0 ~ b26| & b28||\\n    cpy a25 = |b25 ^ ||0 ~ b27| & b29||\\n    cpy a34 = |b34 ^ ||0 ~ b36| & b38||\\n    cpy a35 = |b35 ^ ||0 ~ b37| & b39||\\n    cpy a44 = |b44 ^ ||0 ~ b46| & b48||\\n    cpy a45 = |b45 ^ ||0 ~ b47| & b49||\\n    cpy a06 = |b06 ^ ||0 ~ b08| & b00||\\n    cpy a07 = |b07 ^ ||0 ~ b09| & b01||\\n    cpy a16 = |b16 ^ ||0 ~ b18| & b10||\\n    cpy a17 = |b17 ^ ||0 ~ b19| & b11||\\n    cpy a26 = |b26 ^ ||0 ~ b28| & b20||\\n    cpy a27 = |b27 ^ ||0 ~ b29| & b21||\\n    cpy a36 = |b36 ^ ||0 ~ b38| & b30||\\n    cpy a37 = |b37 ^ ||0 ~ b39| & b31||\\n    cpy a46 = |b46 ^ ||0 ~ b48| & b40||\\n    cpy a47 = |b47 ^ ||0 ~ b49| & b41||\\n    cpy a08 = |b08 ^ ||0 ~ b00| & b02||\\n    cpy a09 = |b09 ^ ||0 ~ b01| & b03||\\n    cpy a18 = |b18 ^ ||0 ~ b10| & b12||\\n    cpy a19 = |b19 ^ ||0 ~ b11| & b13||\\n    cpy a28 = |b28 ^ ||0 ~ b20| & b22||\\n    cpy a29 = |b29 ^ ||0 ~ b21| & b23||\\n    cpy a38 = |b38 ^ ||0 ~ b30| & b32||\\n    cpy a39 = |b39 ^ ||0 ~ b31| & b33||\\n    cpy a48 = |b48 ^ ||0 ~ b40| & b42||\\n    cpy a49 = |b49 ^ ||0 ~ b41| & b43||\\n\\n    cpy rcs = \\n      if |n < 12|\\n      then: if |n < 6|\\n      then: if |n < 3|\\n      then: if |n < 2|\\n      then: if |n < 1|\\n      then: [1,0]\\n      else: [32898,0]\\n      else: [32906,2147483648]\\n      else: if |n < 5|\\n      then: if |n < 4|\\n      then: [2147516416,2147483648]\\n      else: [32907,0]\\n      else: [2147483649,0]\\n      else: if |n < 9|\\n      then: if |n < 8|\\n      then: if |n < 7|\\n      then: [2147516545,2147483648]\\n      else: [32777,2147483648]\\n      else: [138,0]\\n      else: if |n < 11|\\n      then: if |n < 10|\\n      then: [136,0]\\n      else: [2147516425,0]\\n      else: [2147483658,0]\\n      else: if |n < 18|\\n      then: if |n < 15|\\n      then: if |n < 14|\\n      then: if |n < 13|\\n      then: [2147516555,0]\\n      else: [139,2147483648]\\n      else: [32905,2147483648]\\n      else: if |n < 17|\\n      then: if |n < 16|\\n      then: [32771,2147483648]\\n      else: [32770,2147483648]\\n      else: [128,2147483648]\\n      else: if |n < 21|\\n      then: if |n < 20|\\n      then: if |n < 19|\\n      then: [32778,0]\\n      else: [2147483658,2147483648]\\n      else: [2147516545,2147483648]\\n      else: if |n < 23|\\n      then: if |n < 22|\\n      then: [32896,2147483648]\\n      else: [2147483649,0]\\n      else: [2147516424,2147483648]\\n\\n    cpy a00 = |fst rcs ^ a00|\\n    cpy a01 = |snd rcs ^ a01|\\n\\n    (t\\n      |n + 1|\\n      a00 a01 a02 a03 a04 a05 a06 a07 a08 a09\\n      a10 a11 a12 a13 a14 a15 a16 a17 a18 a19\\n      a20 a21 a22 a23 a24 a25 a26 a27 a28 a29\\n      a30 a31 a32 a33 a34 a35 a36 a37 a38 a39\\n      a40 a41 a42 a43 a44 a45 a46 a47 a48 a49))\\n\\ndef keccak.f: {arr}\\n  dup arr = arr\\n  // transform array of 200 bytes into an array of 50 words\\n  dup arr =\\n    let 2num = {b1 b2 b3 b4} |b1 + ||b2 + ||b3 + |b4 << 8|| << 8|| << 8||\\n    let loop = {arr} {cont t} (arr {k} {b1 b2 b3 b4} (cont (k (2num b1 b2 b3 b4))) t)\\n    dup f = (for ~50 #{cont t} (cont t) #loop #{k} (k {x} x))\\n    #{t} (arr (f t))\\n  dup arr = (for ~24 #(pushfront 0 arr) #keccak.f_loop #popfront)\\n  // transform array of 50 words into an array of 50 tuples of 4 bytes\\n  dup arr =\\n    let 2bytes = {x} {t}\\n      cpy x = x\\n      let b1 = |x % 256|\\n      let x = |x >> 8|\\n      cpy x = x\\n      let b2 = |x % 256|\\n      let x = |x >> 8|\\n      cpy x = x\\n      let b3 = |x % 256|\\n      let b4 = |x >> 8|\\n      (t b1 b2 b3 b4)\\n    let init = {cont t} (cont t)\\n    let loop = {arr} {cont t} (arr {k} {num} (cont (k (2bytes num))) t)\\n    let stop = {k} (k {x} x)\\n    dup f = (for ~50 #init #loop #stop)\\n    #{t} (arr (f t))\\n  // transform array of 50 tuples of 4 bytes into an array of 200 bytes\\n  dup arr =\\n    let init = {cont} (cont {t} t)\\n    let loop = {fun} {cont} (fun {k} {tup} (cont {t} (tup (k t))))\\n    let stop = {k} (k {x} x)\\n    dup f = (for ~50 #init #loop #stop)\\n    #(arr f)\\n  #arr\\n\\ndef update_zero: #{t k} (k t)\\ndef pushfront_update: {f update} dup f = f dup update = update #{t k} {x} (update (t (f x)) k)\\ndef pushback_update: {f update} dup f = f dup update = update #{t k} (update t {tup} {x} (k (tup (f x))))\\ndef apply_update: {update arr} dup update = update dup arr = arr #{t} (arr (update t {x} x))\\n\\ndef Keccak256: {bytes}\\n  let state = (for ~200 #{t} t #(pushfront 0) #{x} x)\\n  let update = #update_zero\\n  let fold_cons = {x h i state update}\\n    cpy i = i\\n    (if ||i % 136| == 135|\\n    then: {x h i state update} (h |i + 1| (keccak.f (apply_update (pushback_update {y} |x ^ y| update) state)) update_zero)\\n    else: {x h i state update} (h |i + 1| state (pushback_update {y} |x ^ y| update))\\n    x h i state update)\\n  let fold_nil = {i state update}\\n    dup state = (apply_update (pushback_update {y} |y ^ 1| update) state)\\n    // xor the position 135 of the state with 0x80\\n    let state =\\n      dup f = (for ~135 #{t x} (t |x ^ 128|) #{fun t x} (fun (t x)) #{x} x)\\n      #{t} (state (f t))\\n    dup state = (keccak.f state)\\n    #(state {a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19 a20 a21 a22 a23 a24 a25 a26 a27 a28 a29 a30 a31 a32 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -}\\n      (ConsF a1 (ConsF a2 (ConsF a3 (ConsF a4 (ConsF a5 (ConsF a6 (ConsF a7 (ConsF a8 (ConsF a9 (ConsF a10 (ConsF a11 (ConsF a12 (ConsF a13 (ConsF a14 (ConsF a15 (ConsF a16 (ConsF a17 (ConsF a18 (ConsF a19 (ConsF a20 (ConsF a21 (ConsF a22 (ConsF a23 (ConsF a24 (ConsF a25 (ConsF a26 (ConsF a27 (ConsF a28 (ConsF a29 (ConsF a30 (ConsF a31 (ConsF a32 NilF)))))))))))))))))))))))))))))))))\\n  dup fold = (bytes #fold_cons)\\n# (fold fold_nil 0 state update)\\n\\ndef bytes_to_hex: {xs}\\n  (from_chars\\n  {Cons}\\n  dup Cons = Cons\\n  dup fold =\\n    (xs #{x h}\\n      cpy x = x\\n      let a0 = (num_to_char |x % 16|)\\n      let a1 = (num_to_char |x / 16|)\\n      (Cons a1 (Cons a0 h)))\\n  #{n} (fold n))\\n\\ndef stringtest: \\\"random hash\\\"\\ndef keccaktest: (bytes_to_hex (Keccak256 (to_chars stringtest)))\");\n\n//# sourceURL=webpack:///../formality-core/examples/hash.fmc?");

/***/ }),

/***/ "../formality-core/examples/kaelin.fmc":
/*!*********************************************!*\
  !*** ../formality-core/examples/kaelin.fmc ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// # Kaelin \\n// \\n// A simple MOBA-like boardgame and a showcase for Formality-Core\\n// \\n// It aims to be blockchain-compatible. That means real-time Kaelin matches can\\n// take place inside smart-contract platforms like Ethereum or Tezos. That's\\n// because turns have 10-20 seconds, and moves are made in a commit-reveal\\n// scheme, allowing the game state to be computed by players directly, without\\n// a central server (aka state-channels). In the case of a dispute (such as a\\n// player stopping to respond), the blockchain can be consulted and resolve the\\n// conflict in an acceptable time (about 1 minute).\\n// \\n// Kaelin aims to preserve many of the fun characteristics of a MOBA such as\\n// map control, micro and macro decisions, team-work, and essentially answer\\n// the question: how do you dodge a skillshot in a turn-based boardgame?\\n// \\n// ## Heroes\\n// \\n// Name    | Role       | Description    | MOV | HP  | References & Inspiration\\n// ------- | ---------- | -------------- | --- | --- | -------------------------------------------------\\n// Tophoro | Tank       | Terrain Bender |   2 | 120 | Toph (Avatar TLA), Totoro (Studio Ghibli)\\n// Gonk    | Tank       | Warrior        |   2 |  90 | Gon (Hunter X Hunter), Goku (Gradon Ball Z)\\n// ?       | Tank       | ?              |   ? |   ? | ?\\n// ?       | Tank       | ?              |   ? |   ? | ?\\n// ?       | Tank       | ?              |   ? |   ? | ?\\n// ?       | Tank       | ?              |   ? |   ? | ?\\n// Erkos   | Ranged     | Fire Mage      |   3 |  40 | Erk (Fire Emblem), Harry Potter (Harry Potter)\\n// Croni   | Ranged     | Dark Mage      |   3 |  40 | Chromie (Blizzard), Raven (Teen Titans)\\n// Snarch  | Ranged     | Archer         |   3 |  60 | Zk-Snarks (crypto)\\n// ?       | Ranged     | ?              |   ? |   ? | ?\\n// ?       | Ranged     | ?              |   ? |   ? | ?\\n// ?       | Ranged     | ?              |   ? |   ? | ?\\n// Sirpix  | Melee      | Thief          |   3 |  60 | Dev\\n// Kenlua  | Melee      | Swordsman      |   4 |  60 | Killua (Hunter X Hunter), Kenshin (Rurouni Kenshin)\\n// Flina   | Melee      | Pegasus Knight |   4 |  60 | Florina (Fire Emblem), Link (The Legend of Zelda)\\n// ?       | Melee      | ?              |   ? |   ? | ?\\n// ?       | Melee      | ?              |   ? |   ? | ?\\n// ?       | Melee      | ?              |   ? |   ? | ?\\n// Stanci  | Support    | Healer         |   3 |  40 | Dev\\n// ?       | Support    | ?              |   ? |   ? | ?\\n// ?       | Support    | ?              |   ? |   ? | ?\\n// ?       | Support    | ?              |   ? |   ? | ?\\n// ?       | Support    | ?              |   ? |   ? | ?\\n// ?       | Support    | ?              |   ? |   ? | ?\\n// Zagatur | Influencer | Summoner       |   0 |  10 | Zagara, Abathur (Blizzard)\\n// Agdris  | Influencer | Silencer       |   1 |  20 | Agda, Idris (programming language)\\n// Mewru   | Influencer | Psychic        |   0 |  20 | Mewtwo (Pokémon), Meruem (Hunter X Hunter)\\n// ?       | Influencer | ?              |   ? |   ? | ?\\n// ?       | ?          | ?              |   ? |   ? | ?\\n// ?       | ?          | ?              |   ? |   ? | ?\\n// ?       | ?          | ?              |   ? |   ? | ?\\n// ?       | ?          | ?              |   ? |   ? | ?\\n//\\n// ## Moves\\n// \\n// - Tophoro\\n//   - Earth Lock : selects an enemy in a 5x5 (circle) around. Stuns him/her. Can't use Earth Lock on next turn.\\n//   - Earth Pull : pulls enemies in a 1-3-5 (wave) ahead.\\n//   - Earth Wall : creates up to 3 earth walls in a 5x5 (circle) around.\\n//   - Earth Slam : slams enemies in a 3x3 (square) around, stunning him/her.\\n//   - Earth Root : self-roots for 3 turns, gaining massive shield and heal.\\n// \\n// - Gonk\\n//   - Endure  : can't die on this turn, staying at 1 HP minimum. Can't attack on this turn. Can't use for more than 3 consecutive turns.\\n//   - Breath  : heals 9 HP. Can't move on this turn. \\n//   - Empathy : allies in a 5x5 range can't take damage during this turn. Gonk takes all damage they would take.\\n//   - Counter : select an enemy up to 5 range. If he/she damages Gonk directly during this turn, he/she takes the damage instead.\\n//   - Shatter : select an enemy up to 1 range. Deals an amount of damage inversely proportional to remaining HP.\\n//\\n// - Erkos\\n//   - Flame Ball : hits a 5x5 (circle) up to 4 range.\\n//   - Flame Wave : hits a 1-3-3-5-5 (wave) ahead. Deals 5 damage.\\n//   - Flame Rage : on the next turn, attacks deal +2 dmg. Stacks. Can't attack on this turn.\\n//   - Flame Soul : selects an enemy up to 1 range. Deals massive damage (20?).\\n//   - Flame Nova : loses 30 HP. Deals massive damage in a 11x11 circle (20?).\\n// \\n// - Croni\\n//   - Shadow Doll : places a doll in empty tile for up to 8 range, blocking the way until the end of the turn.\\n//   - Shadow Ball : launches a ball that travels up to 8 tiles ahead, dealing high damage to first enemy hit.\\n//   - Shadow Flux : after a delay, hits a 3x3 (square) in up to 8 range for high damage.\\n//   - Shadow Trap : places a trap in a secret position; activate to reveal and stun in a 3x3 (circle).\\n//   - Shadow Bond : loses half hp. Can't attack on this turn. Can't use on next turn. If Croni dies on this turn, takes the killer with her.\\n//\\n// - Snarch\\n//   - Quick Shot      : hits a selected enemy up to 5 range.\\n//   - Piercing Bolt   : hits all enemies in a 5x1 (line) ahead.\\n//   - Explosive Arrow : hits up to 2 3x3 (circles) up to 5 range.\\n//   - Ballista        : mounts/dismounts from a ballista. Can't attack on this turn. While mounted, can't move and attacks range increase to 12.\\n// \\n// - Sirpix\\n//   - Stealth Clone : creates a stealth in up to 3 range. If already created, moves it 3 steps. \\n//   - Stealth Swap  : reveals your stealth clone's position. If it is an empty tile, swaps with it.\\n//   - Killing Edge  : hits a 3x3 (square) around.\\n// \\n// - Kenlua\\n//   - Dodge : select 4 tiles up to 32 range. Prevent all damage from enemies standing on those tiles during this turn.\\n//   - Slice : hits a 3x3 (square) around, dealing damage. \\n//   - Haste : moves 4 steps. \\n//   - Slash : hits a 1x1 (point) up to 1 range. Deals massive damage. If the hit lands, returns to the position you were at the beginning of the turn.\\n// \\n// - Flina\\n//   - Fly     : Select an position to pick an ally. Moves 4 steps, passing through enemies and cliffs. Afterwards, ally is moved to behind Flina.\\n//   - Lance   : hits a selected enemy up to 2 range.\\n//   - Ocarina : ...\\n// \\n// - Stanci\\n//   - Heal    : selects an ally up to 4 range. Heals him/her.\\n//   - Shield  : selects an ally up to 4 range. Gives him/her armor.\\n//   - Restore : hits a 5x5 (circle) up to 4 range, healing allies inside.\\n//   - Light   : selects an enemy up to 4 range to deal damage.\\n// \\n// - Zagatur\\n//   - Summon : selects an empty tile up to 4 range. Spawns a clone of Zagatur on it.\\n//   - Needle : Hits a 3x1 (line) ahead, dealing damage.\\n//   - Spikes : Hits a 3x3 (circle) around, dealing damage.\\n// \\n// - Agdris\\n//   - Silence : selects up to two enemies up to 12 range. They can't attack on this turn.\\n//   ? Protect : selects up to two allies up to 12 range. Grants him/her 10 armor.\\n//   - Memento : dies. Enemies can't move or attack on this turn.\\n// \\n// - Mewru\\n//   - Psychock    : hits a 3x3 (circle) up to 5 range, dealing damage.\\n//   - Telekinesis : pushes enemies in a 1-3-5 (wave) ahead.\\n//   - Teleport    : selects an empty location on the map. Moves to that location. \\n//   - Absorb      : selects an enemy unit. During this turn, damage dealt by this unit to Mewru heals instead.\\n// \\n// ## Move Priority\\n// \\n// <<Instant: 0>>\\n// - Croni Shadow Trap (activate)\\n// - Agdris Silence\\n// - Agdris Memento\\n//\\n// <<SelfCast: 16>>\\n// - Sirpix Stealth Clone\\n// - Snarch Ballista\\n// - Erkos Flame Rage\\n// - Gonk Endure\\n// - Gonk Breath\\n// - Gonk Counter\\n// - Gonk Empathy \\n// - Tophoro Earth Root\\n// - Mewru Absorb\\n// - Croni Shadow Bond\\n// \\n// <<PointAndClick: 64>>\\n// - Tophoro Earth Lock\\n// - Stanci Shield\\n// - Stanci Heal\\n// - Kenlua Haste\\n// - Kenlua Slice\\n// - Sirpix Stealth Swap\\n// - SirPix Killing Edge\\n// - Stanci Light\\n// - Snarch Quick Shot\\n// - Flina Lance\\n// - Erkos Flame Soul\\n// - Gonk Shatter\\n//\\n// <<TerrainControl: 112>>\\n// - Tophoro Earth Wall\\n// - Croni Shadow Doll\\n//\\n// - <<Walk: 128>>\\n// - Kenlua Walk\\n// - Sirpix Walk\\n// - Flina Walk\\n// - Snarch Walk\\n// - Erkos Walk\\n// - Stanci Walk\\n// - Croni Walk\\n// - Gonk Walk\\n// - Tophoro Walk\\n// - Agdris Walk\\n// - Mewru Walk\\n// - Zagatur Walk\\n//\\n// <<Post-Walk: 160>>\\n// - Flina Fly\\n// - Mewru Teleport\\n// - Kenlua Dodge\\n// \\n// <<Skillshot: 176>>\\n// - Tophoro Earth Pull\\n// - Tophoro Earth Slam\\n// - Kenlua Slash\\n// - Snarch Piercing Bolt\\n// - Snarch Explosive Arrow\\n// - Erkos Flame Wave\\n// - Erkos Flame Ball\\n// - Erkos Flame Nova\\n// - Zagatur Needles\\n// - Zagatur Spikes\\n// - Mewru Telekinesis\\n// - Mewru Psychock\\n// - Croni Shadow Flux\\n// - Croni Shadow Ball\\n// - Stanci Restore\\n//\\n// <<EndTurn: 224>>\\n// - Croni Shadow Trap (place)\\n// - Zagatur Summon\\n\\n// Testing pull action\\ndef kaelin:\\n  dup casts_write = (write ~8)\\n  dup board_write = (write ~10)\\n  dup step        = step\\n  dup earth_pull  = earth_pull\\n  dup flame_wave  = flame_wave\\n  dup print_board = print_board\\n  dup board_inter = board_interact\\n  dup flame_ball  = flame_ball\\n  dup flame_soul  = flame_soul\\n  dup flame_nova  = flame_nova\\n  dup exec_turn   = exec_turn\\n  dup shadow_doll = shadow_doll\\n  dup shadow_flux = shadow_flux\\n  dup quick_shot  = quick_shot\\n  dup piercing_bolt = piercing_bolt\\n  dup explosive_arrow = explosive_arrow\\n  let casts       = empty_casts\\n\\n  # let board = new_board\\n\\n    // Move Croni to below Tophoro\\n    let board = (step [29,1] [0,1] board)\\n    let board = (step [29,2] [0,1] board)\\n    let board = (step [29,3] [1,0] board)\\n\\n    // Throws a flame ball at Erkos and Gonk\\n    let board = (flame_ball [1,30] board)\\n\\n    // Performs an example turn where Tophoro performs Earth Pull down\\n    let casts = (casts_write EARTH_PULL [[30,1], {t}(t [0,1])] casts)\\n    get [board, anims] = (exec_turn casts board)\\n\\n    //let board = (piercing_bolt [24,1] [1,0] board)\\n    let board = (shadow_doll [10, 29] board)\\n    (print_board board)\\n\\n    //[(print_board board), anims]\\n\\ndef damage_visual_effect: {dmg piece}\\n  let case_air    = Cliff\\n  let case_wall   = Wall\\n  let case_cliff  = Cliff\\n  let case_throne = {side} (Throne side)\\n  let case_unit   = {side hero hp} (Unit side hero |hp - dmg|)\\n  (piece case_air case_wall case_cliff case_throne case_unit)\\n\\n// TODO: \\n// - check if the life of \\\"piece\\\" is bigger than the damage\\ndef damage: {dmg piece}\\n  let case_air    = Air\\n  let case_wall   = Wall\\n  let case_cliff  = Cliff\\n  let case_throne = {side} (Throne side)\\n  let case_unit   = {side hero hp} (Unit side hero |hp - dmg|)\\n  (piece case_air case_wall case_cliff case_throne case_unit)\\n\\n// :::::::::::::::\\n// :: Direction ::\\n// :::::::::::::::\\n\\ndef RIGHT : [1,0] //  1\\ndef DOWN  : 1 //  0\\ndef LEFT  : 2 // -1\\ndef UP    : 3 //  0\\n\\n// Transforms a direction [RIGHT, LEFT, UP, DOWN] into a vector that represents that position\\ndef dir_to_vec: {a}\\n  cpy a = a\\n  if |a < 2|\\n  then:\\n    if |a == 0|\\n    then: [ 1,  0]\\n    else: [ 0,  1]\\n  else:\\n    if |a == 2|\\n    then: [-1,  0]\\n    else: [ 0, -1]\\n\\n// ::::::::::\\n// :: Side ::\\n// ::::::::::\\n\\ndef WHITE : 0\\ndef BLACK : 1\\ndef BOARD : 2\\n\\ndef eql_side: {a b}\\n  |a == b|\\n\\ndef side_to_icon: {side}\\n  cpy side = side\\n  if |side == WHITE|\\n  then: (to_chars \\\"O\\\")\\n  else: if |side == BLACK|\\n    then: (to_chars \\\"X\\\")\\n    else: (to_chars \\\"B\\\")\\n\\n// ::::::::::::\\n// :: Heroes ::\\n// ::::::::::::\\n\\ndef TOPHORO : 0\\ndef GONK    : 1\\ndef ERKOS   : 6\\ndef CRONI   : 7\\ndef SNARCH  : 8\\ndef SIRPIX  : 12\\ndef KENLUA  : 13\\ndef FLINA   : 14\\ndef STANCI  : 18\\ndef ZAGATUR : 24\\ndef AGDRIS  : 25\\ndef MEWRU   : 26\\n\\ndef Tophoro : {side} (Unit side TOPHORO 120)\\ndef Gonk    : {side} (Unit side GONK     90)\\ndef Erkos   : {side} (Unit side ERKOS    40)\\ndef Croni   : {side} (Unit side CRONI    40)\\ndef Snarch  : {side} (Unit side SNARCH   60)\\ndef Sirpix  : {side} (Unit side SIRPIX   60)\\ndef Kenlua  : {side} (Unit side KENLUA   60)\\ndef Flina   : {side} (Unit side FLINA    60)\\ndef Stanci  : {side} (Unit side STANCI   40)\\ndef Zagatur : {side} (Unit side ZAGATUR  10)\\ndef Agdris  : {side} (Unit side AGDRIS   20)\\ndef Mewru   : {side} (Unit side MEWRU    20)\\n\\ndef hero_name:\\n  let hero00 = (to_chars \\\"Tophoro \\\")\\n  let hero01 = (to_chars \\\"Gonk    \\\")\\n  let hero02 = (to_chars \\\"Missna  \\\")\\n  let hero03 = (to_chars \\\"Missna  \\\")\\n  let hero04 = (to_chars \\\"Missna  \\\")\\n  let hero05 = (to_chars \\\"Missna  \\\")\\n  let hero06 = (to_chars \\\"Erkos   \\\")\\n  let hero07 = (to_chars \\\"Croni   \\\")\\n  let hero08 = (to_chars \\\"Snarch  \\\")\\n  let hero09 = (to_chars \\\"Missna  \\\")\\n  let hero10 = (to_chars \\\"Missna  \\\")\\n  let hero11 = (to_chars \\\"Missna  \\\")\\n  let hero12 = (to_chars \\\"Sirpix  \\\")\\n  let hero13 = (to_chars \\\"Kenlua  \\\")\\n  let hero14 = (to_chars \\\"Flina   \\\")\\n  let hero15 = (to_chars \\\"Missna  \\\")\\n  let hero16 = (to_chars \\\"Missna  \\\")\\n  let hero17 = (to_chars \\\"Missna  \\\")\\n  let hero18 = (to_chars \\\"Stanci  \\\")\\n  let hero19 = (to_chars \\\"Missna  \\\")\\n  let hero20 = (to_chars \\\"Missna  \\\")\\n  let hero21 = (to_chars \\\"Missna  \\\")\\n  let hero22 = (to_chars \\\"Missna  \\\")\\n  let hero23 = (to_chars \\\"Missna  \\\")\\n  let hero24 = (to_chars \\\"Zagatur \\\")\\n  let hero25 = (to_chars \\\"Agdris  \\\")\\n  let hero26 = (to_chars \\\"Mewru   \\\")\\n  let hero27 = (to_chars \\\"Missna  \\\")\\n  let hero28 = (to_chars \\\"Missna  \\\")\\n  let hero29 = (to_chars \\\"Missna  \\\")\\n  let hero30 = (to_chars \\\"Missna  \\\")\\n  let hero31 = (to_chars \\\"Missna  \\\")\\n  let quad00 = [[[hero00,hero01],[hero02,hero03]],[[hero04,hero05],[hero06,hero07]]]\\n  let quad01 = [[[hero08,hero09],[hero10,hero11]],[[hero12,hero13],[hero14,hero15]]]\\n  let quad02 = [[[hero16,hero17],[hero18,hero19]],[[hero20,hero21],[hero22,hero23]]]\\n  let quad03 = [[[hero24,hero25],[hero26,hero27]],[[hero28,hero29],[hero30,hero31]]]\\n  let heroes = [[quad00,quad01],[quad02,quad03]]\\n  dup take   = (take ~5)\\n  # {hero} snd (take hero NilF heroes)\\n\\ndef hero_icon:\\n  let hero00 = (to_chars \\\"To\\\")\\n  let hero01 = (to_chars \\\"Go\\\")\\n  let hero02 = (to_chars \\\"??\\\")\\n  let hero03 = (to_chars \\\"??\\\")\\n  let hero04 = (to_chars \\\"??\\\")\\n  let hero05 = (to_chars \\\"??\\\")\\n  let hero06 = (to_chars \\\"Er\\\")\\n  let hero07 = (to_chars \\\"Cr\\\")\\n  let hero08 = (to_chars \\\"Sn\\\")\\n  let hero09 = (to_chars \\\"??\\\")\\n  let hero10 = (to_chars \\\"??\\\")\\n  let hero11 = (to_chars \\\"??\\\")\\n  let hero12 = (to_chars \\\"Sr\\\")\\n  let hero13 = (to_chars \\\"Kl\\\")\\n  let hero14 = (to_chars \\\"Fl\\\")\\n  let hero15 = (to_chars \\\"??\\\")\\n  let hero16 = (to_chars \\\"??\\\")\\n  let hero17 = (to_chars \\\"??\\\")\\n  let hero18 = (to_chars \\\"St\\\")\\n  let hero19 = (to_chars \\\"??\\\")\\n  let hero20 = (to_chars \\\"??\\\")\\n  let hero21 = (to_chars \\\"??\\\")\\n  let hero22 = (to_chars \\\"??\\\")\\n  let hero23 = (to_chars \\\"??\\\")\\n  let hero24 = (to_chars \\\"Za\\\")\\n  let hero25 = (to_chars \\\"Ag\\\")\\n  let hero26 = (to_chars \\\"Me\\\")\\n  let hero27 = (to_chars \\\"??\\\")\\n  let hero28 = (to_chars \\\"??\\\")\\n  let hero29 = (to_chars \\\"??\\\")\\n  let hero30 = (to_chars \\\"??\\\")\\n  let hero31 = (to_chars \\\"??\\\")\\n  let quad00 = [[[hero00,hero01],[hero02,hero03]],[[hero04,hero05],[hero06,hero07]]]\\n  let quad01 = [[[hero08,hero09],[hero10,hero11]],[[hero12,hero13],[hero14,hero15]]]\\n  let quad02 = [[[hero16,hero17],[hero18,hero19]],[[hero20,hero21],[hero22,hero23]]]\\n  let quad03 = [[[hero24,hero25],[hero26,hero27]],[[hero28,hero29],[hero30,hero31]]]\\n  let heroes = [[quad00,quad01],[quad02,quad03]]\\n  dup take   = (take ~5)\\n  # {hero} snd (take hero NilF heroes)\\n\\n// :::::::::::\\n// :: Piece ::\\n// :::::::::::\\n\\ndef Air:\\n  {Air Wall Cliff Throne Unit}\\n  Air\\n\\ndef Wall:\\n  {Air Wall Cliff Throne Unit}\\n  Wall\\n\\ndef Cliff:\\n  {Air Wall Cliff Throne Unit}\\n  Cliff\\n\\ndef Throne: {side}\\n  {Air Wall Cliff Throne Unit}\\n  (Throne side)\\n\\ndef Unit: {hero side hp}\\n  {Air Wall Cliff Throne Unit}\\n  (Unit hero side hp)\\n\\ndef piece_icon:\\n  dup hero_icon = hero_icon\\n  # {piece}\\n    let case_air    = (to_chars \\\" .\\\")\\n    let case_wall   = (to_chars \\\" W\\\")\\n    let case_cliff  = (to_chars \\\" C\\\")\\n    let case_throne = {side} (to_chars \\\" T\\\")\\n    let case_unit   = {side hero hp} (hero_icon hero)\\n    (piece case_air case_wall case_cliff case_throne case_unit)\\n\\ndef piece_info:\\n  dup hero_name = hero_name\\n  # {piece}\\n    let case_air    = [Air, NilF]\\n    let case_wall   = [Wall, NilF]\\n    let case_cliff  = [Cliff, NilF]\\n    let case_throne = {side} [(Throne side), NilF]\\n    let case_unit   = {side hero hp}\\n      cpy hero = hero\\n      cpy hp   = hp\\n      cpy side = side\\n      let val  = (Unit side hero hp)\\n      let info =\\n        (concat (hero_name hero) // Hero name\\n        (concat (to_chars \\\": \\\")\\n        (concat (ConsF (box_byte (num_to_char ||hp / 100| % 10|)) NilF) // HP\\n        (concat (ConsF (box_byte (num_to_char ||hp /  10| % 10|)) NilF) // HP\\n        (concat (ConsF (box_byte (num_to_char ||hp /   1| % 10|)) NilF) // HP\\n        (concat (to_chars \\\" hp -- \\\")\\n        (concat (if side [(to_chars \\\"black\\\"),(to_chars \\\"white\\\")])\\n                (ConsF #10 NilF))))))))\\n      [val, info]\\n    (piece case_air case_wall case_cliff case_throne case_unit)\\n\\ndef piece_cpy_with: {fn piece}\\n  let case_air    = {fn} [Air, (fn Air)]\\n  let case_wall   = {fn} [Wall, (fn Wall)]\\n  let case_cliff  = {fn} [Cliff, (fn Cliff)]\\n  let case_throne = {side} {fn}\\n    cpy side = side\\n    [(Throne side), (fn (Throne side))]\\n  let case_unit = {side hero hp} {fn}\\n    cpy side = side\\n    cpy hero = hero\\n    cpy hp   = hp\\n    [(Unit side hero hp), (fn (Unit side hero hp))]\\n  (piece case_air case_wall case_cliff case_throne case_unit fn)\\n\\ndef piece_is_hero: {hero piece}\\n  let case_air    = 0\\n  let case_wall   = 0\\n  let case_cliff  = 0\\n  let case_throne = {a_side} 0\\n  let case_unit   = {a_side a_hero a_hp} |a_hero == hero|\\n  (piece case_air case_wall case_cliff case_throne case_unit)\\n\\n// \\\"a\\\" and \\\"b\\\" are side positions. The function checks if they can swap their position, that is, simulate a walk, and returns:\\n// - The same position: if they can't interact with each other.\\n// - Inverted position: the elements interacted and one now occupies the position of the other.\\ndef a_step_to_b: {a b}\\n  let case_a_air      = {b} [Air, b]\\n  let case_a_wall     = {b} [Wall, b]\\n  let case_a_cliff    = {b} [Cliff, b]\\n  let case_a_throne   = {a_side} {b} [(Throne a_side), b]\\n  let case_a_unit     = {a_side a_hero a_hp} {b}\\n    let case_b_air    = {a_side a_hero a_hp}\\n      let a_val       = (Unit a_side a_hero a_hp)\\n      let b_val       = Air\\n      [b_val, a_val]\\n    let case_b_wall   = {a_side a_hero a_hp}\\n      let a_val       = (Unit a_side a_hero a_hp)\\n      let b_val       = Wall\\n      [a_val, b_val]\\n    let case_b_cliff  = {a_side a_hero a_hp}\\n      let a_val       = (Unit a_side a_hero a_hp)\\n      let b_val       = Cliff\\n      [a_val, b_val]\\n    let case_b_throne = {b_side} {a_side a_hero a_hp}\\n      let a_val       = (Unit a_side a_hero a_hp)\\n      let b_val       = (Throne b_side)\\n      [a_val, b_val]\\n    let case_b_unit   = {b_side b_hero b_hp} {a_side a_hero a_hp}\\n      cpy a_side      = a_side\\n      cpy b_side      = b_side\\n      let a_val       = (Unit a_side a_hero a_hp)\\n      let b_val       = (Unit b_side b_hero b_hp)\\n      let can_pass    = (eql_side a_side b_side)\\n      let then_swap   = [{a b}[b,a],{a b}[a,b]]\\n      (if can_pass then_swap a_val b_val)\\n    (b case_b_air case_b_wall case_b_cliff case_b_throne case_b_unit a_side a_hero a_hp)\\n  (a case_a_air case_a_wall case_a_cliff case_a_throne case_a_unit b)\\n\\n// :::::::::::\\n// :: Board ::\\n// :::::::::::\\n\\ndef new_board:\\n  let O   = Air\\n  let a   = (Gonk WHITE)\\n  let b   = (Erkos WHITE)\\n  let c   = (Kenlua WHITE)\\n  let d   = (Mewru WHITE)\\n  let e   = (Tophoro BLACK)\\n  let f   = (Croni BLACK)\\n  let g   = (Stanci BLACK)\\n  let h   = (Flina BLACK)\\n  let W   = Wall\\n  let C   = Cliff\\n  let x   = (Throne WHITE)\\n  let y   = (Throne BLACK)\\n  let r00 = [[[[[W,W],[W,W]],[[W,W],[W,O]]],[[[O,W],[W,O]],[[O,O],[O,W]]]],[[[[W,O],[O,O]],[[O,W],[W,O]]],[[[O,W],[W,W]],[[y,W],[W,W]]]]]\\n  let r01 = [[[[[W,O],[O,W]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[h,g]],[[O,f],[e,W]]]]]\\n  let r02 = [[[[[W,W],[W,W]],[[W,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,C],[O,O]],[[O,O],[O,W]]]]]\\n  let r03 = [[[[[W,O],[O,W]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]\\n  let r04 = [[[[[W,O],[W,W]],[[W,W],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,C],[O,O]],[[O,O],[O,W]]]]]\\n  let r05 = [[[[[W,O],[O,W]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]\\n  let r06 = [[[[[W,W],[W,W]],[[W,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[W,O]],[[O,O],[W,W]]]]]\\n  let r07 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]\\n\\n  let r08 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]\\n  let r09 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]\\n  let r10 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]\\n  let r11 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]\\n  let r12 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]\\n  let r13 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]\\n  let r14 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]\\n  let r15 = [[[[[C,C],[C,C]],[[C,C],[C,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[C,C],[C,C]],[[C,C],[C,C]]]]] // MID\\n\\n  let r16 = [[[[[C,C],[C,C]],[[C,C],[C,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[C,C],[C,C]],[[C,C],[C,C]]]]] // MID\\n  let r17 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]\\n  let r18 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]\\n  let r19 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]\\n  let r20 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]\\n  let r21 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]\\n  let r22 = [[[[[W,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,W]]]]]\\n  let r23 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]\\n\\n  let r24 = [[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]]]\\n  let r25 = [[[[[W,W],[O,O]],[[O,W],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[W,W]],[[W,W],[W,W]]]]]\\n  let r26 = [[[[[W,O],[O,O]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,O]],[[O,O],[O,W]]]]]\\n  let r27 = [[[[[W,O],[O,O]],[[O,O],[C,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[W,W],[W,W]]]]]\\n  let r28 = [[[[[W,O],[O,O]],[[O,O],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[O,O],[O,W]]]]]\\n  let r29 = [[[[[W,O],[O,O]],[[O,O],[C,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[O,W],[W,W]]]]]\\n  let r30 = [[[[[W,a],[b,O]],[[c,d],[W,O]]],[[[O,O],[O,O]],[[O,O],[O,O]]]],[[[[O,O],[O,O]],[[O,O],[O,O]]],[[[O,W],[O,W]],[[O,W],[O,W]]]]]\\n  let r31 = [[[[[W,W],[W,x]],[[W,W],[W,O]]],[[[O,W],[W,O]],[[O,O],[O,W]]]],[[[[W,O],[O,O]],[[O,W],[W,O]]],[[[O,W],[W,W]],[[W,W],[W,W]]]]]\\n  [[[[[r00,r01],[r02,r03]],[[r04,r05],[r06,r07]]],[[[r08,r09],[r10,r11]],[[r12,r13],[r14,r15]]]],\\n   [[[[r16,r17],[r18,r19]],[[r20,r21],[r22,r23]]],[[[r24,r25],[r26,r27]],[[r28,r29],[r30,r31]]]]]\\n\\n// Simulates an index in an array of 1024 elements (32x32 map).\\n// x: column\\n// y: line \\ndef board_index: {pos}\\n  get [x,y] = pos\\n  ||y * 32| + x|\\n\\ndef board_interact:\\n  dup write = (write ~10)\\n  dup take  = (take ~10)\\n  # {a_pos b_pos fun board}\\n    cpy a_idx         = (board_index a_pos)\\n    cpy b_idx         = (board_index b_pos)\\n    get [board,a_val] = (take a_idx Air board)\\n    get [board,b_val] = (take b_idx Air board)\\n    get [a_val,b_val] = (fun a_val b_val)\\n    let board         = (write a_idx a_val board)\\n    let board         = (write b_idx b_val board)\\n   board \\n\\n// Apply a function to a board piece\\ndef board_apply:\\n  dup write = (write ~10)\\n  dup take  = (take ~10)\\n  # {pos fun board}\\n    cpy p_idx       = (board_index pos)\\n    get [board,val] = (take p_idx Air board)\\n    let p_update    = (fun val)\\n    let board       = (write p_idx p_update board)\\n  board\\n\\ndef print_board:\\n  dup fold = (fold_array ~10)\\n  dup piece_info = #piece_info\\n  dup piece_icon = #piece_icon\\n  # {board}\\n    dup piece_info = piece_info\\n    dup piece_icon = piece_icon\\n    let fold_node = {lft rgt}\\n      get [lft_info, lft_board] = lft\\n      get [rgt_info, rgt_board] = rgt\\n      [(concat lft_info rgt_info), (concat lft_board rgt_board)]\\n    let fold_leaf = {piece}\\n      get [piece, info] = (piece_info piece)\\n      [info, (piece_icon piece)]\\n    get [info, board] = (fold board #fold_node #fold_leaf)\\n    let board = (cons-every #64 #10 board)\\n    (from_chars (concat (ConsF 10 NilF) (concat info (concat board (ConsF 10 NilF)))))\\n\\n// :::::::::::::\\n// :: Effects ::\\n// :::::::::::::\\n\\n// Given a position and a direction to step forward, move the element (if is possible) and return the updated map\\ndef step:\\n  dup inter = board_interact\\n  # {a_pos a_dxy board}\\n    get [a_pos0,a_pos1] = (vec2_cpy a_pos)\\n    let b_pos           = (vec2_add a_pos0 a_dxy)\\n    (inter a_pos1 b_pos a_step_to_b board)\\n\\ndef earth_pull:\\n  dup step = step\\n  let area = (vec2_wave_in (ConsF #1 (ConsF #3 (ConsF #5 NilF))))\\n  let hits = {pos dxy board} (step pos dxy board)\\n  (area #hits)\\n\\n// Hits a 1-3-3-5-5 (wave). Deals 5 damage.\\ndef flame_wave:\\n  let area = (vec2_wave (ConsF #1 (ConsF #3 (ConsF #3 (ConsF #5 (ConsF #5 NilF))))))\\n  let hits = {pos board} (board_apply pos (damage 5) board)  \\n  (area #hits)\\n  \\n// Hits a 5x5 (circle). Deals 5 damage.\\ndef flame_ball:\\n  let area = vec2_circle_e\\n  let hits = {pos board} (board_apply pos (damage 5) board)\\n  //let hits = {pos board} (board_apply pos (damage_visual_effect 5) board)\\n  (area #hits)\\n\\n// Deals massive damage (20?)\\ndef flame_soul:\\n  let hits = {pos board} (board_apply pos (damage 20) board)\\n  //let hits = {pos board} (board_apply pos (damage_visual_effect 20) board)\\n  hits\\n\\n// Deals massive damage in a 11x11 circle (20?)\\ndef flame_nova:\\n  let area = vec2_circle_j\\n  let hits = {pos board} (board_apply pos (damage 20) board)\\n  //let hits = {pos board} (board_apply pos (damage_visual_effect 20) board)\\n  (area #hits)\\n\\n\\n// Places a doll in an empty tile\\ndef shadow_doll: {pos board}\\n  let case_air     = Wall\\n  let case_wall    = Wall\\n  let case_cliff   = Cliff\\n  let case_throne  = {side} (Throne side)\\n  let case_unit    = {side hero hp} (Unit side hero hp)\\n  let change_piece = {t} (t case_air case_wall case_cliff case_throne case_unit)\\n  (board_apply pos change_piece board)\\n\\n// launches a ball that travels up to 8 tiles ahead, dealing high damage to first enemy hit\\n//def shadow_ball: \\n//  let form = \\n\\n// Hits a 3x3 (square) with for high damage (15?).\\ndef shadow_flux:\\n  let form = vec2_circle_c\\n  //let hits = {pos board} (board_apply pos (damage 15) board)\\n  let hits = {pos board} (board_apply pos (damage_visual_effect 15) board) \\n  (form #hits)\\n\\n// Hits a selected enemy. Deals 5 damage\\ndef quick_shot: \\n  // {pos board} (board_apply pos (damage 5) board)\\n  {pos board} (board_apply pos (damage_visual_effect 5) board)\\n   \\n// Hits all enemies in a 5x1 (line) ahead. Deals 3 damage.\\ndef piercing_bolt:\\n  let form = (vec2_wave (ConsF #1 (ConsF #1 (ConsF #1 (ConsF #1 (ConsF #1 NilF))))))\\n  let hits = {pos board} (board_apply pos (damage_visual_effect 3) board)\\n  (form #hits) \\n\\n// Explosive Arrow : hits up to 2 3x3 (circles). Deals 2 damage.\\ndef explosive_arrow:\\n  let form = vec2_circle_b\\n  let hits = {pos board} (board_apply pos (damage_visual_effect 2) board)\\n  # {pos1 pos2 board}\\n    let board = (form #hits pos1 board)\\n    let board = (form #hits pos2 board)\\n    board\\n    \\n\\n// :::::::::::\\n// :: Moves ::\\n// :::::::::::\\n\\ndef PASS       : 0\\ndef EARTH_PULL : 176\\n\\n// TODO: we need an array init function that doesn't add 2 levels\\ndef empty_casts:\\n  let a = [0,0]\\n  let b = [a,a]\\n  let c = [b,b]\\n  let d = [c,c]\\n  let e = [d,d]\\n  let f = [e,e]\\n  let g = [f,f]\\n  let h = [g,g]\\n  [h,h]\\n\\ndef exec_turn:\\n  // Config\\n  dup casts_take  = (take ~8)\\n  dup casts_write = (write ~8)\\n  dup board_take  = (take ~10)\\n  dup board_write = (write ~10)\\n\\n  // Function\\n  # {casts board}\\n\\n    // Utils\\n    let get_cast  = {skill casts} (casts_take skill 0 casts)\\n    let get_piece = {pos board} (board_take (board_index pos) Air board)\\n\\n    // Animations\\n    let anims = Nil\\n\\n    // EARTH_PULL\\n    // TODO: abstract this logic in a single `hero_use_skill` function\\n    get [casts,cast]  = (get_cast EARTH_PULL casts)\\n    get [pos,args]    = cast\\n    get [pos,pos0]    = (vec2_cpy pos)\\n    get [board,piece] = (get_piece pos0 board)\\n    get [piece,allow] = (piece_cpy_with (piece_is_hero TOPHORO) piece)\\n    get [pos,pos0]    = (vec2_cpy pos)\\n    get [board,anims] = \\n      ( if allow\\n        then: {board anims}\\n          let board = (args (earth_pull pos0) board)\\n          let anims = (Cons \\\"Tophoro used Earth Pull.\\\" anims)\\n          [board, anims]\\n        else: {board anims}\\n          [board, (Cons \\\"Invalid use of Earth Pull.\\\" anims)]\\n        board anims)\\n    let board = (board_write (board_index pos) piece board)\\n\\n    // Result\\n    [board, anims]\\n\\n//W W W W W W W . . W W . . . . W W . . . . W W . . W W W T W W W\\n//W . . W . . W . . . . . . . . . . . . . . . . . . W X X . X X W\\n//W W W W W . W . . . . . . . . . . . . . . . . . . C . . . . . W\\n//W . . W . . W . . . . . . . . . . . . . . . . . . W . . . . . W\\n//W . W W W W W . . . . . . . . . . . . . . . X . . C . . . . . W\\n//W . . W . . . . . . . . . . . . . . . . X X X X X W . . . . . W\\n//W W W W W . W . . . . . . . . . . . . X X X X X X W W . . . W W\\n//. . . . . . . . . . . . . X X . . . X X X X X X X X X . . . . .\\n//. . . . . . . . . . . X X X X . . . X X X X X X X X X . . . . .\\n//W . . . . . . . . E X X X X X . . X X X X X T X X X X X . . . W\\n//W . . . . . . . . . . X X X X . . . X X X X X X X X X . . . . W\\n//W . . . . . . . . . . . . X X . . . X X X X X X X X X . . . . W\\n//. . . . . . . . . . . . . . . . . . . X X X X X X X . . . . . .\\n//. . . . . . . . . . . . . . . . C . . . X X X X X . . . . . . .\\n//. . . . . . . . . . . . . . X X S . . . . . X . . . . . . . . .\\n//C C C C C C C . . . . . . X X X X X . . . . . . C C C C C C C C\\n//C C C C C C C . . . . E . X X T X X . . . . . . C C C C C C C C\\n//. . . . . . . . . . . . . X X X X X . . . . . . . . . . . . . .\\n//. . . . . . . . . . . . . . X X X . . . . . . . . . . . . . . .\\n//. . . . . . . . . . . . . . . . . . . . . X X X . . . . . . . .\\n//W . . . . P . . . . . . . . . . . . . . . X T X . . . . . . . W\\n//W . . . . . . X . . . K . . . . . X . . . X X X . . . . . . . W\\n//W . . . . . . . . . . . . . . . X X . . . . . . . . . . . . . W\\n//. . . . O O . . . . . . . . T X X X . . . . . . . . . . . . . .\\n//. . . . . . . . . . . . . . . . X X . . . . . . . . . . . . . .\\n//W W . . . W W . . . . . . . . . . X . . . . . . . W W W W W W W\\n//W . . . . . W . . . . . . . . . . . . . . . . . . W . . . . . W\\n//W . . . . . C . . . . . . . . . . . . . . . . . . W . W W W W W\\n//W . . . . . W . . . . . . . . . . . . . . . . . . W . W . . . W\\n//W . . . . . C . . . . . . . . . . . . . . . . . . W . W . W W W\\n//W O . K . O W . . . . . . . . . . . . . . . . . . W . W . W . W\\n//W W W T W W W . . W W . . . . W W . . . . W W . . W W W W W W W\\\"\\n\\n//W W W W W W W . . W W . . . . W W . . . . W W . . W W W T W W W\\n//W . . W . . W . . . . . . . M . . . . . . . . . . W X X . X X W\\n//W W W W W . W . . . . . . M M M . . . . . . . . . C . . . . . W\\n//W . . W . . W . . . . . M M M M M . . . . . . . . W . . . . . W\\n//W . W W W W W . . . . M M M M M M M . . . . . . . C . . . . . W\\n//W . . W . . . . . . M M M M O M M M M . . . . . . W . . . . . W\\n//W W W W W . W . . M M M M O O O M M M M . . . . . W W . . . W W\\n//. . . . . . . . M M M M O O O O O M M M M . . . . . . . . . . .\\n//. . . . . . . M M M M O O O O O O O M M M M . . . . . X . . . .\\n//W . . . . . M M M M O O O O 4 O O O O M M M M . . . X X X . . W\\n//W . . . . M M M M O O O O 4 4 4 O O O O M M M M . . . X . . . W\\n//W . . . M M M M O O O O 4 4 4 4 4 O O O O M M M M . . . . . . W\\n//. . . M M M M O O O O 4 4 4 4 4 4 4 O O O O M M M M . . . . . .\\n//. . M M M M O O O O 4 4 4 4 C 4 4 4 4 O O O O M M M M . . . . .\\n//. . . M M M M O O O O 4 4 4 4 4 4 4 O O O O M M M M . . . . . .\\n//C C C C C C C M O O O O 4 4 4 4 4 O O O O M M M C C C C C C C C\\n//C C C C C C C M M O O O O 4 4 4 O O O O M M M M C C C C C C C C\\n//. . . . . . M M M M O O O O 4 O O O O M M M M . . . . . . . . .\\n//. . . . . . . M M M M O O O O O O O M M M M . . . . . . . . . .\\n//. . . . . . . . M M M M O O O O O M M M M . . . . . . . . . . .\\n//W . . . . . . . . M M M M O O O M M M M . . . . . . . . . . . W\\n//W . . . . . . . . . M M M M O M M M M . . . C . . . . . . . . W\\n//W . . . . . . . . . . M M M M M M M . . . . 4 . . . . . . . . W\\n//. . . . O O . . . . . . M M M M M . . . . . 4 . . . . . . . . .\\n//. . . . . . . . . . . . . M M M . . . . . . 4 . . . . . . . . .\\n//W W . . . W W . . . . . . . M . . . . . . . 4 . . W W W W W W W\\n//W . . . . . W . . . . . . . . . . . . . . . O . . W . . . . . W\\n//W . . . . . C . . . . . . . . . . . . . . . O . . W . W W W W W\\n//W . . . . . W . . . . . . . . . . . . . . . O . . W . W . . . W\\n//W . . . . . C . . . . . . . . . . . . . . . O . . W . W . W W W\\n//W O . . . O W . . . . . . . . . . . . . . . . . . W . W . W . W\\n//W W W T W W W . . W W . . . . W W . . . . W W . . W W W W W W W\\\"\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/kaelin.fmc?");

/***/ }),

/***/ "../formality-core/examples/list.fmc":
/*!*******************************************!*\
  !*** ../formality-core/examples/list.fmc ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Scott-encoded functions\\n\\ndef Cons: {x xs}\\n  {c n} (c x xs)\\n\\ndef Nil:\\n  {c n} n\\n\\ndef head:\\n  {x xs} (xs {x xs}x x)\\n\\ndef tail:\\n  {xs} (xs {x xs}xs Nil)\\n\\n// Church-encoded functions\\n\\ndef ConsF: {x xs}\\n  {Cons}\\n  dup x    = x\\n  dup Cons = Cons\\n  dup func = (xs #Cons)\\n  # {nil} (Cons x (func nil))\\n\\ndef NilF:\\n  {Cons}\\n  # {nil} nil\\n\\ndef list_unfold: {list}\\n  dup F = (list #Cons)\\n  # (F nil)\\n\\ndef build: {len init loop} {cons}\\n  dup loop = loop\\n  dup init = init\\n  dup cons = cons\\n  dup fold = (len #{list state}\\n    get [state, element] = (loop state)\\n    (cons element (list state)))\\n  # {nil} (fold {state}nil init)\\n\\n// Concatenates two lists\\ndef concat: {a b}\\n  {Cons}\\n  dup Cons = Cons\\n  dup append-a = (a #Cons)\\n  dup append-b = (b #Cons)\\n  # {nil} (append-a (append-b nil))\\n\\n// Converts Scott to Church in O(len).\\ndef list_fold_f: {len Cons}\\n  dup Cons = Cons\\n  let func = {cont list}\\n    let case_cons = {head tail nil} (Cons head (cont tail nil))\\n    let case_nil  = {nil} nil\\n    (list case_cons case_nil)\\n  dup fold = (len #func)\\n  # {nil list} (fold {tail}{nil}nil list nil)\\n\\n// Non-fused version of the function above.\\ndef list_fold: {len}\\n  dup fold_f = (list_fold_f len #ConsF)\\n  # {list} (fold_f NilF list)\\n\\ndef map: {as f Cons}\\n  dup f = f\\n  dup Cons = Cons\\n  let case_cons = {a} (Cons (f a))\\n  dup A = (as #case_cons)\\n  # {Nil} (A Nil)\\n\\n// reverse tail call and fusionable\\ndef reverse:\\n  {as}\\n  let iterate = {xs ys Cons}\\n    dup Cons = Cons\\n    dup rec = (xs #{x h p} (h (Cons x p)))\\n    dup p = (ys #Cons)\\n    #{N} (rec {p} p (p N))\\n  (iterate as NilF)\\n\\ndef filter:\\n// {:(List !A)} {:!{:!A} Bool} !(List !A)\\n  {xs p}\\n  dup p = p\\n  {Cons}\\n  dup Cons = Cons\\n  dup rec = (xs #{x h}\\n    dup x = x\\n    (p #x {r} (Cons #x r) {r} r h))\\n  #{N} (rec N)\\n\\n\\n// Concatenates `val` after every `num` elements of `list`\\ndef cons-every: {num val list}\\n  dup num = num\\n  dup val = val\\n  {Cons}\\n  dup Cons = Cons\\n  let cons = {x xs nm}\\n    get [n,m] = nm\\n    cpy n     = n\\n    cpy m     = m\\n    let ConsIf = {cond} if cond\\n      then: {x xs} (Cons x xs)\\n      else: {x xs} xs\\n    let mod0 = ||n % m| == 0|\\n    let list = (Cons x (xs [|n + 1|, m]))\\n    (ConsIf mod0 val list)\\n  dup fold = (list #cons)\\n  # {nil} (fold {nm}nil [0,num])\\n\\ndef foldl: {as op}\\n  dup op = op\\n  dup rec = (as #{a h} (op h a))\\n  #{b} (rec b)\\n\\ndef foldr: {as op}\\n  dup op = op\\n  dup rec = (as #{a h} (op a h))\\n  # {b} (rec b)\\n\\ndef example_list: (reverse (map (ConsF #3 (ConsF #4 (ConsF #7 (ConsF #2 (ConsF #0 NilF))))) #{x} |x * 2|))\\ndef example_foldr: (foldr example_list #{x y} |x + y|)\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/list.fmc?");

/***/ }),

/***/ "../formality-core/examples/main.fmc":
/*!*******************************************!*\
  !*** ../formality-core/examples/main.fmc ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def add_test:\\n  |3 + 2|\\n\\ndef mul_test:\\n  |3 * 2|\\n\\ndef tup_test:\\n  (tup_fst (Tup 42 1337))\\n\\ndef pair_test:\\n  fst [42 , 1337]\\n\\ndef list_test:\\n  (Cons #1 (Cons #2 (Cons #3 Nil)))\\n\\ndef list_fold_test:\\n  dup fold = (list_fold ~3)\\n  # (fold list_test)\\n\\ndef list_fold_f_test:\\n  {Cons}\\n  dup fold_f = (list_fold_f ~3 Cons)\\n  # {Nil} (fold_f Nil list_test)\\n\\ndef if_test:\\n  if 1\\n  then: \\\"cond is true\\\"\\n  else: \\\"cond is false\\\"\\n\\ndef cpy_test:\\n  cpy num = 42\\n  [[num, num], |num + num|]\\n\\ndef prj_test:\\n  get [fst, snd] = [42, 1337]\\n  (tup fst snd)\\n\\ndef fib_test:\\n  (fib ~65536)\\n\\ndef to_chars_test:\\n  (to_chars \\\"abcdefgh\\\")\\n\\ndef string_concat_test:\\n  (string_concat \\\"Hello, \\\" \\\"world!\\\")\\n\\ndef sum_test:\\n  let upto = ~100000\\n  let init =\\n    [0, 0]\\n  let loop = {state}\\n    get [idx, sum] = state\\n    cpy idx        = idx\\n    [|idx + 1|, |sum + idx|]\\n  let done = {state} snd state\\n  (for upto #init #loop #done)\\n\\ndef term_test:\\n  term_example\\n\\ndef array_test:\\n  array_example\\n\\ndef main:\\n  string_concat_test\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/main.fmc?");

/***/ }),

/***/ "../formality-core/examples/maybe.fmc":
/*!********************************************!*\
  !*** ../formality-core/examples/maybe.fmc ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def None:\\n  {None Just}\\n  None\\n\\ndef Just: {val}\\n  {None Just}\\n  (Just val)\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/maybe.fmc?");

/***/ }),

/***/ "../formality-core/examples/nat.fmc":
/*!******************************************!*\
  !*** ../formality-core/examples/nat.fmc ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// :::::::::\\n// :: Nat ::\\n// :::::::::\\n\\n// Church-encoded Nats are used to perform bounded loops and recursion.\\n// See the examples on the end of the file to see how they work!\\n\\ndef Zero:\\n  {Succ Zero}\\n  Zero\\n\\ndef Succ: {pred}\\n  {Succ Zero}\\n  (Succ pred)\\n\\ndef ZeroF:\\n  {s}\\n  # {z} z\\n\\ndef SuccF: {n}\\n  {s}\\n  dup s = s\\n  dup f = (n #s)\\n  # {z} (s (f z))\\n\\ndef mul: {a b}\\n  {s} \\n  dup S = s\\n  dup A =\\n    dup B = (b #S)\\n    (a #B)\\n  # {z} (A z)\\n\\n// Bounded for-loop\\ndef for: {numb init loop stop}\\n  dup init = init\\n  dup exec = (numb loop)\\n  dup stop = stop\\n  # (stop (exec init))\\n\\ndef nat_to_chars: {nat}\\n  let init = (to_chars \\\"Z\\\")\\n  let loop = {chars} (concat (to_chars \\\"S\\\") chars)\\n  let stop = {chars} chars\\n  (for nat #init #loop #stop)\\n\\ndef nat_to_string: {nat}\\n  dup chars = (nat_to_chars nat)\\n  # (from_chars chars) \\n\\ndef nat_unfold: {n}\\n  let init = Zero\\n  let loop = Succ\\n  let stop = {x}x\\n  (for n #init #loop #stop)\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/nat.fmc?");

/***/ }),

/***/ "../formality-core/examples/num.fmc":
/*!******************************************!*\
  !*** ../formality-core/examples/num.fmc ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Gets the nth number of the Fibonacci sequence\\ndef fib: {n}\\n  let init = [0,1]\\n  let loop = {state}\\n    get [a, b] = state\\n    cpy b      = b\\n    [b, |a + b|]\\n  let stop = {state}\\n    (snd state)\\n  (for n #init #loop #stop)\\n\\ndef boxed_add: {x y}\\n  dup x = x\\n  dup y = y\\n  # |x + y|\\n\\ndef num_dif: {a b}\\n  cpy a = a\\n  cpy b = b\\n  if |a > b|\\n  then: |a - b|\\n  else: |b - a|\\n\\ndef num_to_char: {n}\\n  cpy n = n\\n  if |n < 10|\\n  then: |n + 48|\\n  else: |n + 87|\\n\\n// box_byte\\n// : {n : Num} !Num\\ndef box_byte: {n}\\n  cpy n = n\\n  dup b00 = if ||n >>  0| & 1| [#{x}|x + 0x1|, #{x}x]\\n  dup b01 = if ||n >>  1| & 1| [#{x}|x + 0x2|, #{x}x]\\n  dup b02 = if ||n >>  2| & 1| [#{x}|x + 0x4|, #{x}x]\\n  dup b03 = if ||n >>  3| & 1| [#{x}|x + 0x8|, #{x}x]\\n  dup b04 = if ||n >>  4| & 1| [#{x}|x + 0x10|, #{x}x]\\n  dup b05 = if ||n >>  5| & 1| [#{x}|x + 0x20|, #{x}x]\\n  dup b06 = if ||n >>  6| & 1| [#{x}|x + 0x40|, #{x}x]\\n  dup b07 = if ||n >>  7| & 1| [#{x}|x + 0x80|, #{x}x]\\n  # (b07 (b06 (b05 (b04 (b03 (b02 (b01 (b00 0))))))))\\n\\n// box_num\\n// : {n : Num} !Num\\ndef box_num: {n}\\n  cpy n = n\\n  dup b00 = if ||n >>  0| & 1| [#{x}|x + 0x1|, #{x}x]\\n  dup b01 = if ||n >>  1| & 1| [#{x}|x + 0x2|, #{x}x]\\n  dup b02 = if ||n >>  2| & 1| [#{x}|x + 0x4|, #{x}x]\\n  dup b03 = if ||n >>  3| & 1| [#{x}|x + 0x8|, #{x}x]\\n  dup b04 = if ||n >>  4| & 1| [#{x}|x + 0x10|, #{x}x]\\n  dup b05 = if ||n >>  5| & 1| [#{x}|x + 0x20|, #{x}x]\\n  dup b06 = if ||n >>  6| & 1| [#{x}|x + 0x40|, #{x}x]\\n  dup b07 = if ||n >>  7| & 1| [#{x}|x + 0x80|, #{x}x]\\n  dup b08 = if ||n >>  8| & 1| [#{x}|x + 0x100|, #{x}x]\\n  dup b09 = if ||n >>  9| & 1| [#{x}|x + 0x200|, #{x}x]\\n  dup b10 = if ||n >> 10| & 1| [#{x}|x + 0x400|, #{x}x]\\n  dup b11 = if ||n >> 11| & 1| [#{x}|x + 0x800|, #{x}x]\\n  dup b12 = if ||n >> 12| & 1| [#{x}|x + 0x1000|, #{x}x]\\n  dup b13 = if ||n >> 13| & 1| [#{x}|x + 0x2000|, #{x}x]\\n  dup b14 = if ||n >> 14| & 1| [#{x}|x + 0x4000|, #{x}x]\\n  dup b15 = if ||n >> 15| & 1| [#{x}|x + 0x8000|, #{x}x]\\n  dup b16 = if ||n >> 16| & 1| [#{x}|x + 0x10000|, #{x}x]\\n  dup b17 = if ||n >> 17| & 1| [#{x}|x + 0x20000|, #{x}x]\\n  dup b18 = if ||n >> 18| & 1| [#{x}|x + 0x40000|, #{x}x]\\n  dup b19 = if ||n >> 19| & 1| [#{x}|x + 0x80000|, #{x}x]\\n  dup b20 = if ||n >> 20| & 1| [#{x}|x + 0x100000|, #{x}x]\\n  dup b21 = if ||n >> 21| & 1| [#{x}|x + 0x200000|, #{x}x]\\n  dup b22 = if ||n >> 22| & 1| [#{x}|x + 0x400000|, #{x}x]\\n  dup b23 = if ||n >> 23| & 1| [#{x}|x + 0x800000|, #{x}x]\\n  dup b24 = if ||n >> 24| & 1| [#{x}|x + 0x1000000|, #{x}x]\\n  dup b25 = if ||n >> 25| & 1| [#{x}|x + 0x2000000|, #{x}x]\\n  dup b26 = if ||n >> 26| & 1| [#{x}|x + 0x4000000|, #{x}x]\\n  dup b27 = if ||n >> 27| & 1| [#{x}|x + 0x8000000|, #{x}x]\\n  dup b28 = if ||n >> 28| & 1| [#{x}|x + 0x10000000|, #{x}x]\\n  dup b29 = if ||n >> 29| & 1| [#{x}|x + 0x20000000|, #{x}x]\\n  dup b30 = if ||n >> 30| & 1| [#{x}|x + 0x40000000|, #{x}x]\\n  dup b31 = if ||n >> 31| & 1| [#{x}|x + 0x80000000|, #{x}x]\\n  # (b31 (b30 (b29 (b28 (b27 (b26 (b25 (b24\\n    (b23 (b22 (b21 (b20 (b19 (b18 (b17 (b16\\n    (b15 (b14 (b13 (b12 (b11 (b10 (b09 (b08\\n    (b07 (b06 (b05 (b04 (b03 (b02 (b01 (b00\\n      0))))))))))))))))))))))))))))))))\\n\\ndef num_from_nat: {n}\\n  dup fold = (n #{x}|x + 1|)\\n  # (fold 0)\\n\\ndef sqrt: {n}\\n  |n ^^ 2147483648|\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/num.fmc?");

/***/ }),

/***/ "../formality-core/examples/package.json":
/*!***********************************************!*\
  !*** ../formality-core/examples/package.json ***!
  \***********************************************/
/*! exports provided: name, version, description, main, scripts, repository, author, license, bugs, homepage, default */
/***/ (function(module) {

eval("module.exports = {\"name\":\"formality-core-stdlib\",\"version\":\"0.1.0\",\"description\":\"\",\"main\":\"_export_to_webpack_.js\",\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/moonad/formality-core.git\"},\"author\":\"\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/moonad/formality-core/issues\"},\"homepage\":\"https://github.com/moonad/formality-core#readme\"};\n\n//# sourceURL=webpack:///../formality-core/examples/package.json?");

/***/ }),

/***/ "../formality-core/examples/pair.fmc":
/*!*******************************************!*\
  !*** ../formality-core/examples/pair.fmc ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def Pair: {a b}\\n  [a, b]\\n\\ndef pair_fst: {pair}\\n  fst pair\\n\\ndef pair_snd: {pair}\\n  snd pair\\n\\ndef pair_prj: {pair func}\\n  get [val0, val1] = pair\\n  (func val0 val1)\\n\\ndef swap: {pair}\\n  get [a, b] = pair\\n  [b, a]\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/pair.fmc?");

/***/ }),

/***/ "../formality-core/examples/string.fmc":
/*!*********************************************!*\
  !*** ../formality-core/examples/string.fmc ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def TEXT: 1954047348\\n\\n// Converts an UTF-8 string into a list of bytes\\ndef to_chars: {str}\\n  {Cons}\\n  dup Cons = Cons\\n  let Cons-non-0 = {c}\\n    cpy c = c\\n    if |c > 0|\\n    then: (Cons c)\\n    else: {x} x\\n  dup f =\\n    let func = {c cs}\\n      cpy c = c\\n      let Cons-c0 = (Cons-non-0 ||c >>  0| & 0xFF|)\\n      let Cons-c1 = (Cons-non-0 ||c >>  8| & 0xFF|)\\n      let Cons-c2 = (Cons-non-0 ||c >> 16| & 0xFF|)\\n      let Cons-c3 = (Cons-non-0 ||c >> 24| & 0xFF|)\\n      (Cons-c0 (Cons-c1 (Cons-c2 (Cons-c3 cs))))\\n    (snd str #func)\\n  # {nil} (f nil)\\n\\n// Converts a list of bytes back to an UTF-8 string\\ndef from_chars: {chars}\\n  let nums =\\n    {Cons}\\n    dup Cons = Cons\\n    dup func =\\n      let loop = {c cont char indx}\\n        cpy indx = indx\\n        cpy char = ||char >> 8| | |c << 24||\\n        cpy done = ||indx % 4| == 3|\\n        let Cons-char =\\n          if done\\n          then: (Cons char)\\n          else: {x}x\\n        let next-char =\\n          if done\\n          then: 0\\n          else: char\\n        (Cons-char (cont next-char |indx + 1|))\\n      (chars #loop)\\n    # {nil} (func {char indx}(Cons char nil) 0 0)\\n  [TEXT, nums]\\n\\ndef string_concat: {a b}\\n  (from_chars (concat (to_chars a) (to_chars b)))\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/string.fmc?");

/***/ }),

/***/ "../formality-core/examples/term.fmc":
/*!*******************************************!*\
  !*** ../formality-core/examples/term.fmc ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// Formality implementation in Formality-Core (ongoing work)\\n\\n// Example usage of this library\\n\\ndef term_example:\\n  dup true_t    = #(Lam {t} (Lam {f} t))\\n  dup false_t   = #(Lam {t} (Lam {f} f))\\n  dup not_t     = #(Lam {b} (App (App b false_t) true_t))\\n  dup main_t    = #(App not_t (App not_t (App not_t true_t)))\\n  dup reduce    = (reduce ~256)\\n  dup to_string = (to_string ~256)\\n  # [\\n    [\\\"term:\\\", (to_string main_t)],\\n    [\\\"norm:\\\", (to_string (reduce (main_t)))]]\\n\\n// Scott-encoded functions\\n\\ndef Lam: {body}\\n  {Lam App Var}\\n  (Lam body)\\n\\ndef App: {func argm}\\n  {Lam App Var}\\n  (App func argm)\\n\\ndef Var: {indx}\\n  {Lam App Var}\\n  (Var indx)\\n\\n// Church-encoded functions\\n\\ndef LamF: {body}\\n  {Lam App Var}\\n  dup Lam  = Lam\\n  dup App  = App\\n  dup Var  = Var\\n  dup body = (body #Lam #App #Var)\\n  # (Lam body)\\n\\ndef AppF: {func argm}\\n  {Lam App Var}\\n  dup Lam  = Lam\\n  dup App  = App\\n  dup Var  = Var\\n  dup func = (func #Lam #App #Var)\\n  dup argm = (argm #Lam #App #Var)\\n  # (App func argm)\\n\\ndef VarF: {indx}\\n  {Lam App Var}\\n  dup Lam  = Lam\\n  dup App  = App\\n  dup Var  = Var\\n  dup indx = indx\\n  # (Var indx)\\n\\n// This is how we convert from Scott to Church in O(len).\\ndef term_fold_f: {len Lam App Var}\\n  dup Lam = Lam\\n  dup App = App\\n  dup Var = Var\\n  let func = {cont term}\\n    let case_lam = {body cont}\\n      get [cont, body] = (cont body)\\n      [cont, (Lam body)]\\n    let case_app = {func argm cont}\\n      get [cont, func] = (cont func)\\n      get [cont, argm] = (cont argm)\\n      [cont, (App func argm)]\\n    let case_var = {indx cont}\\n      [cont, (Var indx)]\\n    (term case_lam case_app case_var cont)\\n  dup fold = (len #func)\\n  # {term} (snd (fold {term}[{x}x,term] term))\\n\\n// Non-fused version of the function above.\\ndef term_fold: {len}\\n  dup fold_f = (term_fold_f len #LamF #AppF #VarF)\\n  # {term} (fold_f term_test)\\n\\ndef term_to_string: {len}\\n  let case_lam = {body}\\n    (concat (to_chars \\\"λ\\\") body)\\n  let case_app = {func argm}\\n    (concat (to_chars \\\"(\\\")\\n    (concat func\\n    (concat (to_chars \\\" \\\")\\n    (concat argm (to_chars \\\")\\\")))))\\n  let case_var = {indx}\\n    (to_chars (nat_to_string indx))\\n  dup fold_f = (term_fold_f len #case_lam #case_app #case_var)\\n  # {term} (from_chars (fold_f term))\\n  \\ndef reduce: {len}\\n  let func = {cont term}\\n    let lam_case = {body cont}\\n      [cont, (Lam body)]\\n    let app_case = {func argm cont}\\n      let lam_case = {fbody argm cont} \\n        get [cont, term] = (cont (fbody argm))\\n        [cont, term]\\n      let app_case = {ffunc fargm argm cont}\\n        get [cont, argm] = (cont argm)\\n        [cont, (App (App ffunc fargm) argm)]\\n      let var_case = {findx argm cont}\\n        [cont, findx]\\n      get [cont, func] = (cont func)\\n      (func lam_case app_case var_case argm cont)\\n    let var_case = {indx cont}\\n      [cont, (Var indx)]\\n    (term lam_case app_case var_case cont)\\n  dup fold = (len #func)\\n  # {term} (snd (fold {term}[{x}x,term] term))\\n\\ndef to_string: {len}\\n  let TERM_TO_CHARS = {a b}a\\n  let NUMB_TO_CHARS = {a b}b\\n  let init = {term} [{x}x, term]\\n  let loop = {call name}\\n    let term_to_chars = {call term dept}\\n      let lam_case = {body call dept}\\n        cpy dept         = dept\\n        get [call, body] = (call TERM_TO_CHARS (body (Var dept)) |dept + 1|)\\n        [call, (concat (to_chars \\\"λ\\\") body)]\\n      let app_case = {func argm call dept}\\n        cpy dept         = dept\\n        get [call, func] = (call TERM_TO_CHARS func dept)\\n        get [call, argm] = (call TERM_TO_CHARS argm dept)\\n        [call, (concat (to_chars \\\"(\\\") (concat func (concat (to_chars \\\" \\\") (concat argm (to_chars (\\\")\\\"))))))]\\n      let var_case = {indx call dept}\\n        get [call, indx] = (call NUMB_TO_CHARS indx)\\n        [call, indx]\\n      (term lam_case app_case var_case call dept)\\n    let numb_to_chars = {call num}\\n      let succ_case = {pred call}\\n        get [call, pred] = (call NUMB_TO_CHARS pred)\\n        [call, (concat (to_chars \\\"S\\\") pred)]\\n      let zero_case = {call}\\n        [call, (to_chars \\\"Z\\\")]\\n      cpy num = num\\n      (if |num > 0| [(succ_case |num - 1|),zero_case] call)\\n    (name term_to_chars numb_to_chars call)\\n  let stop = {call term}\\n    get [call, chrs] = (call TERM_TO_CHARS term 0)\\n    (from_chars chrs)\\n  (for len #init #loop #stop)\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/term.fmc?");

/***/ }),

/***/ "../formality-core/examples/tree.fmc":
/*!*******************************************!*\
  !*** ../formality-core/examples/tree.fmc ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def NodeF: {lft rgt}\\n  {Node Leaf}\\n  dup Node = Node\\n  dup Leaf = Leaf\\n  dup lft  = (lft #Node #Leaf)\\n  dup rgt  = (rgt #Node #Leaf)\\n  # (Node lft rgt)\\n\\ndef LeafF: {val}\\n  {Node Leaf}\\n  dup Node = Node\\n  dup Leaf = Leaf\\n  dup val  = val\\n  # (Leaf val)\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/tree.fmc?");

/***/ }),

/***/ "../formality-core/examples/tuple.fmc":
/*!********************************************!*\
  !*** ../formality-core/examples/tuple.fmc ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"def Tup: {a b}\\n  {tup} (tup a b)\\n\\ndef tup_fst: {tup}\\n  (tup {a b}a)\\n\\ndef tup_snd: {tup}\\n  (tup {a b}b)\\n\\ndef pushfront: {a tup} {t} (tup (t a))\\ndef pushback: {a tup} {t} (tup t a)\\ndef popfront: {tup} {t} (tup {-} t)\\n\\ndef empty_tup: {t} t\\n\\ndef concat_tup: {tup1 tup2} {t}\\n  (tup2 (tup1 t))\\n\\ndef example_tup: (concat_tup (pushfront 0 (pushback 4 (pushback 3 (pushfront 1 (pushfront 2 empty_tup))))) (pushfront 5 empty_tup))\\n\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/tuple.fmc?");

/***/ }),

/***/ "../formality-core/examples/vector2.fmc":
/*!**********************************************!*\
  !*** ../formality-core/examples/vector2.fmc ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"// ::::::::::\\n// :: Vec2 ::\\n// ::::::::::\\n\\n// vec2_add\\n// | Receives two 2D vectors and adds them\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   [Num,Num]\\ndef vec2_add: {a b}\\n  get [ax,ay] = a\\n  get [bx,by] = b\\n  [|ax + bx|, |ay + by|]\\n\\n// vec2_scale\\ndef vec2_scale: {a s}\\n  get [ax,ay] = a\\n  [|ax * s|, |ay * s|]\\n\\n// vec2_neg\\n// | Negates a 2D vector\\n// : {a : [Num,Num]}\\n//   [Num,Num]\\ndef vec2_neg: {a}\\n  get [ax,ay] = a\\n  [|0 - ax|, |0 - ay|]\\n\\n// vec2_cpy\\n// | Copies a 2D vector\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   [[Num,Num], [Num,Num]]\\ndef vec2_cpy: {a}\\n  get [ax,ay] = a\\n  cpy ax      = ax\\n  cpy ay      = ay\\n  [[ax,ay], [ax,ay]]\\n\\n// vec2_sqr_dist\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   Num\\ndef vec2_sqr_dist: {a b}\\n  get [ax,ay] = a\\n  get [bx,by] = b\\n  cpy dx = |(num_dif ax bx) ** 2|\\n  cpy dy = |(num_dif ay by) ** 2|\\n  |dx + dy|\\n\\n// vec2_dist\\n// : {a : [Num,Num]}\\n//   {b : [Num,Num]}\\n//   Num\\ndef vec2_dist: {a b}\\n  (sqrt (vec2_sqr_dist a b))\\n\\n// vec2_line\\n// | Up to `max_len`, given a length `len`, a center pos `pos`, and a displacement\\n// | vector `dxy`, returns vectors from `pos`, incrementing by `dxy`, `len` times.\\n// : {max_len : Nat}\\n//   {-P      : Type}\\n//   {cons    : ! {x : [Num,Num]} {xs : P} P}\\n// ! {len     : Num}\\n//   {pos     : [Num,Num]}\\n//   {dxy     : [Num,Num]}\\n//   {nil     : P}\\n//   P\\ndef vec2_line: {max_len} {cons}\\n  dup cons = cons\\n  dup fold = (max_len #{list len pos dxy}\\n    get [ax,ay] = pos\\n    get [dx,dy] = dxy\\n    cpy len = len\\n    cpy ax  = ax\\n    cpy ay  = ay\\n    cpy dx  = dx\\n    cpy dy  = dy\\n    (if |len == 0|\\n      then: {list} (list 0 [0,0] [0,0])\\n      else: {list} (cons [ax,ay] (list |len - 1| [|ax + dx|,|ay + dy|] [dx,dy]))\\n      list))\\n  # {len pos dxy nil}\\n    (fold {len pos dxy}nil len pos dxy)\\n\\n// vec2_area\\n// : {mlen : Nat}\\n//   {-P   : Type}\\n//   {size : [Num,Num]}\\n//   {cond : ! {x : [Num,Num]} Num}\\n//   {cons : ! {x : [Num,Num]} {xs : P} P}\\n// ! {pos  : [Num,Num]}\\n//   {siz  : [Num,Num]}\\n//   {nil  : P}\\n//   P\\ndef vec2_area: {mlen size cond} {cons}\\n  dup cons = cons\\n  dup size = size\\n  dup cond = cond\\n  dup fold = (mlen #{list pos idx}\\n    get [cx,cy] = pos\\n    get [sx,sy] = size\\n    cpy sx = sx\\n    cpy sy = sy\\n    cpy cx = cx\\n    cpy cy = cy\\n    cpy ix = idx\\n    cpy px = ||cx + |ix % sx|| - |sx / 2||\\n    cpy py = ||cy + |ix / sx|| - |sy / 2||\\n    let fn = (if (cond [cx,cy] [sx,sy] [px,py]) [(cons [px,py]),{x}x])\\n    let xs = (list [cx,cy] |ix + 1|)\\n    (fn xs))\\n  # {pos nil}\\n    (fold {pos idx}nil pos 0)\\n\\n// vec2_rect\\n// : {mlen : Nat}\\n//   {-P   : Type}\\n//   {size : [Num,Num]}\\n//   {cons : ! {x : [Num,Num]} {xs : P} P}\\n// ! {pos  : [Num,Num]}\\n//   {siz  : [Num,Num]}\\n//   {nil  : P}\\n//   P\\ndef vec2_rect: {mlen size}\\n  (vec2_area mlen size #{cen siz pos}1)\\n\\ndef vec2_rect_example: {cons}\\n  dup cons = cons\\n  dup area = (vec2_rect ~16 #[4,4] #cons)\\n  # (area [100,100])\\n\\n//vec2_circle\\n// : {mlen : Nat}\\n//   {-P   : Type}\\n//   {srad : Num} -- squared radius\\n//   {cons : ! {pos : [Num,Num]} {state : P} P}\\n// ! {pos  : [Num,Num]}\\n//   {nil  : P}\\n//   P\\ndef vec2_circle: {mlen srad cons}\\n  dup cons = cons\\n  dup srad = srad\\n  let isin = {cen siz pos} |(vec2_sqr_dist cen pos) < srad|\\n  dup size = #||(sqrt srad) * 2| + 1|\\n  dup area = (vec2_area mlen #[size,size] #isin #cons)\\n  # {pos} (area pos)\\n\\n// . . .\\n// . x .\\n// . . .\\ndef vec2_circle_a: (vec2_circle ~1 #1)\\n\\n// . . . . .\\n// . . x . .\\n// . x x x .\\n// . . x . .\\n// . . . . .\\ndef vec2_circle_b: (vec2_circle ~9 #2)\\n\\n// . . . . .\\n// . x x x .\\n// . x x x .\\n// . x x x .\\n// . . . . .\\ndef vec2_circle_c: (vec2_circle ~9 #3)\\n\\n// . . . . . . .\\n// . . . x . . .\\n// . . x x x . .\\n// . x x x x x .\\n// . . x x x . .\\n// . . . x . . .\\n// . . . . . . .\\ndef vec2_circle_d: (vec2_circle ~25 #5)\\n\\n// . . . . . . .\\n// . . x x x . .\\n// . x x x x x .\\n// . x x x x x .\\n// . x x x x x .\\n// . . x x x . .\\n// . . . . . . .\\ndef vec2_circle_e: (vec2_circle ~25 #6)\\n\\n// . . . . . . .\\n// . x x x x x .\\n// . x x x x x .\\n// . x x x x x .\\n// . x x x x x .\\n// . x x x x x .\\n// . . . . . . .\\ndef vec2_circle_f: (vec2_circle ~25 #9)\\n\\n// . . . . . . . . .\\n// . . . . x . . . .\\n// . . x x x x x . .\\n// . . x x x x x . .\\n// . x x x x x x x .\\n// . . x x x x x . .\\n// . . x x x x x . .\\n// . . . . x . . . .\\n// . . . . . . . . .\\ndef vec2_circle_g: (vec2_circle ~49 #10)\\n\\n// . . . . . . . . .\\n// . . . x x x . . .\\n// . . x x x x x . .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . . x x x x x . .\\n// . . . x x x . . .\\n// . . . . . . . . .\\ndef vec2_circle_h: (vec2_circle ~49 #11)\\n\\n// . . . . . . . . .\\n// . . x x x x x . .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . x x x x x x x .\\n// . . x x x x x . .\\n// . . . . . . . . .\\ndef vec2_circle_i: (vec2_circle ~49 #14)\\n\\n// . . . . . . . . . . .\\n// . . . . . x . . . . .\\n// . . . x x x x x . . .\\n// . . x x x x x x x . .\\n// . . x x x x x x x . .\\n// . x x x x x x x x x .\\n// . . x x x x x x x . .\\n// . . x x x x x x x . .\\n// . . . x x x x x . . .\\n// . . . . . x . . . . .\\n// . . . . . . . . . . .\\ndef vec2_circle_j: (vec2_circle ~81 #17)\\n\\n// Approximates the area of a circle (2*pi*r)\\ndef vec2_circle_example: \\n  let radi = 9\\n  let form = (vec2_circle ~2048 #||radi * radi| + 1|)\\n  let hits = {pos num} |num + 1|\\n  dup circ = (form #hits)\\n  # (circ [0,0] 0)\\n\\n// vec2_wave\\n// | Given a list of widths, returns vectors filling a wave from `pos` pointing to `dir`.\\n// : {widths : {-P : Type} {cons : ! {w : Num} {ws : P} P} ! {nil : P} P}\\n//   {-P     : Type}\\n//   {cons   : ! {pos : [Num,Num]} {res : P} P}\\n// ! {pos    : [Num,Num]}\\n//   {dxy    : [Num,Num]}\\n//   {nil    : P}\\n//   P\\ndef vec2_wave: {widths} {cons}\\n  dup cons = cons\\n  dup line = (vec2_line ~7 #cons)\\n  dup fold = (widths #{w ws pos dxy}\\n    get [ax,ay] = pos\\n    get [dx,dy] = dxy\\n    cpy w  = w\\n    cpy ax = ax\\n    cpy ay = ay\\n    cpy dx = dx\\n    cpy dy = dy\\n    cpy nx = dy\\n    cpy ny = |0 - dx|\\n    let ix = |ax - |nx * |w / 2||| \\n    let iy = |ay - |ny * |w / 2|||\\n    let t  = (ws [|ax + dx|,|ay + dy|] [dx,dy])\\n    (line w [ix,iy] [nx,ny] t))\\n  # {pos dxy nil}\\n    (fold {pos dxy}nil pos dxy)\\n\\n// vec2_wave_out\\n// : {widths : {-P : Type} {cons : ! {w : Num} {ws : P} P} ! {nil : P} P}\\n//   {-P     : Type}\\n//   {cons   : ! {pos : [Num,Num]} {dir : [Num,Num]} {res : P} P}\\n// ! {pos    : [Num,Num]}\\n//   {dxy    : [Num,Num]}\\n//   {nil    : P}\\n//   P\\ndef vec2_wave_out: {widths} {cons} \\n  dup cons = cons\\n  dup wave = (vec2_wave widths #{pos rest dxy}\\n    get [dxy0,dxy1] = (vec2_cpy dxy)\\n    (cons pos dxy0 (rest dxy1)))\\n  # {pos dxy nil}\\n    get [dxy0,dxy1] = (vec2_cpy dxy)\\n    (wave pos dxy0 {dxy}nil dxy1)\\n\\n// vec2_wave_in\\n// : {widths : {-P : Type} {cons : ! {w : Num} {ws : P} P} ! {nil : P} P}\\n//   {-P     : Type}\\n//   {cons   : ! {pos : [Num,Num]} {dir : [Num,Num]} {res : P} P}\\n// ! {pos    : [Num,Num]}\\n//   {dxy    : [Num,Num]}\\n//   {nil    : P}\\n//   P\\ndef vec2_wave_in: {widths} {cons} \\n  dup cons = cons\\n  dup wave = (vec2_wave widths #{pos rest res dxy}\\n    get [dxy0,dxy1] = (vec2_cpy dxy)\\n    (rest (cons pos dxy0 res) dxy1))\\n  # {pos dxy nil}\\n    get [dxy0,dxy1] = (vec2_cpy dxy)\\n    (wave pos dxy0 {res dxy}res nil (vec2_neg dxy1))\\n\");\n\n//# sourceURL=webpack:///../formality-core/examples/vector2.fmc?");

/***/ }),

/***/ "./node_modules/formality-core/exports.js":
/*!************************************************!*\
  !*** ./node_modules/formality-core/exports.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var fm = module.exports = {\n  core: __webpack_require__(/*! ./fm-core.js */ \"./node_modules/formality-core/fm-core.js\"),\n  net: __webpack_require__(/*! formality-net */ \"./node_modules/formality-net/fm-net.js\"),\n  to_net: __webpack_require__(/*! ./fm-to-net.js */ \"./node_modules/formality-core/fm-to-net.js\"),\n  to_js: __webpack_require__(/*! ./fm-to-js.js */ \"./node_modules/formality-core/fm-to-js.js\"),\n  norm, check, exec\n};\n\nfunction norm(term, defs, mode = \"OPTIMAL_LAZY\", stats = {}) {\n  switch (mode) {\n    case \"BOXED\":\n      return fm.core.norm(term, defs, false);\n    case \"UNBOXED\":\n      return fm.core.norm(term, defs, true);\n    case \"NATIVE\":\n      return fm.to_js.decompile(fm.to_js.compile(term, defs));\n    case \"OPTIMAL_STRICT\":\n    case \"OPTIMAL_LAZY\":\n      var net = fm.to_net.compile(term, defs);\n      if (stats && stats.input_net === null) {\n        stats.input_net = JSON.parse(JSON.stringify(net));\n      }\n      if (mode === \"OPTIMAL_LAZY\") {\n        var new_stats = net.reduce_lazy(stats || {});\n      } else {\n        var new_stats = net.reduce_strict(stats || {});\n      }\n      if (stats && stats.output_net !== undefined) {\n        stats.output_net = JSON.parse(JSON.stringify(net));\n      }\n      return fm.to_net.decompile(net);\n  }\n}\n\nfunction exec(name, defs, infs, mode = \"OPTIMAL_LAZY\", bipass = false, stats = {}) {\n  if (defs[name] && defs[name][0] === \"Ref\" && !defs[defs[name][1].name]) {\n    name = defs[name][1].name;\n  }\n  if (defs[name]) {\n    return fm.norm(check(defs[name], defs, bipass), defs, mode, stats);\n  } else if (infs[name]) {\n    var data = infs[name];\n    var init = check(data.init, defs, bipass);\n    var step = check(data.step, defs, bipass);\n    var stop = check(data.stop, defs, bipass);\n    var done = check(data.done, defs, bipass);\n    var term = fm.core.norm(init, mode, stats);\n    var cont = term => {\n      var res = fm.norm(fm.core.App(stop, term), defs, mode, stats);\n      if (res[0] === \"Put\") {\n        res = res[1].expr;\n      }\n      return res[0] === \"Num\" && res[1].numb === 0;\n    }\n    while (cont(term)) {\n      term = fm.norm(fm.core.App(step, term), defs, mode, stats);\n      stats.loops += 1;\n    }\n    term = fm.norm(fm.core.App(done, term), defs, mode, stats);\n    return term;\n  } else {\n    throw \"Definition '\" + name + \"' not found.\";\n  }\n}\n\nfunction check(term, defs, bipass = false) {\n  if (!bipass) {\n    try {\n      fm.core.check(term, defs);\n      return term;\n    } catch (e) {\n      console.log(e.toString());\n      process.exit();\n    }\n  } else {\n    return term;\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/formality-core/exports.js?");

/***/ }),

/***/ "./node_modules/formality-core/fm-core.js":
/*!************************************************!*\
  !*** ./node_modules/formality-core/fm-core.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ~~ Formality Core Language ~~\n\n// ::::::::::\n// :: Term ::\n// ::::::::::\n\n// An ESCoC term is an ADT represented by a JSON\nconst Var = (index)                  => [\"Var\", {index}];\nconst Lam = (name, body)             => [\"Lam\", {name, body}];\nconst App = (func, argm)             => [\"App\", {func, argm}];\nconst Put = (expr)                   => [\"Put\", {expr}];\nconst Dup = (name, expr, body)       => [\"Dup\", {name, expr, body}];\nconst Num = (numb)                   => [\"Num\", {numb}];\nconst Op1 = (func, num0, num1)       => [\"Op1\", {func, num0, num1}];\nconst Op2 = (func, num0, num1)       => [\"Op2\", {func, num0, num1}];\nconst Ite = (cond, pair)             => [\"Ite\", {cond, pair}];\nconst Cpy = (name, numb, body)       => [\"Cpy\", {name, numb, body}];\nconst Par = (val0, val1)             => [\"Par\", {val0, val1}];\nconst Fst = (pair)                   => [\"Fst\", {pair}];\nconst Snd = (pair)                   => [\"Snd\", {pair}];\nconst Prj = (nam0, nam1, pair, body) => [\"Prj\", {nam0, nam1, pair, body}];\nconst Ref = (name)                   => [\"Ref\", {name}];\n\n// :::::::::::::\n// :: Parsing ::\n// :::::::::::::\n\n// Converts a string to a term\nconst parse = (code) => {\n  function is_space(char) {\n    return char === \" \" || char === \"\\t\" || char === \"\\n\" || char === \"\\r\";\n  }\n\n  function is_newline(char) {\n    return char === \"\\n\";\n  }\n\n  function is_name_char(char) {\n    return \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.-\".indexOf(char) !== -1;\n  }\n\n  function next() {\n    if (is_newline(code[idx])) {\n      row += 1;\n      col = 0;\n    } else {\n      col += 1;\n    }\n    idx += 1;\n  }\n\n  function skip_spaces() {\n    while (idx < code.length && is_space(code[idx])) {\n      next();\n    }\n  }\n\n  function next_char() {\n    skip_spaces();\n    while (code.slice(idx, idx + 2) === \"//\") {\n      while (code[idx] !== \"\\n\" && idx < code.length) {\n        next();\n      }\n      skip_spaces();\n    }\n  }\n\n  function match(string) {\n    next_char();\n    var sliced = code.slice(idx, idx + string.length);\n    if (sliced === string) {\n      for (var i = 0; i < string.length; ++i) {\n        next();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  function parse_exact(string) {\n    if (!match(string)) {\n      var text = \"\";\n      var part = \"\";\n      text += \"Parse error: expected '\" + string + \"' \";\n      text += \"on line \" + (row+1) + \", col \" + col + \", but found '\" + code[idx] + \"' instead. Relevant code:\\n\";\n      for (var ini = idx, il = 0; il < 6 && ini >=          0; --ini) if (code[ini] === \"\\n\") ++il;\n      for (var end = idx, el = 0; el < 6 && end < code.length; ++end) if (code[end] === \"\\n\") ++el;\n      part += code.slice(ini+1, idx) + \"<HERE>\" + code.slice(idx, end);\n      text += part.split(\"\\n\").map((line,i) => (\"    \" + (row-il+i+1)).slice(-4) + \"| \" + line).join(\"\\n\");\n      throw text;\n    }\n  }\n\n  function parse_string(fn = is_name_char) {\n    next_char();\n    var name = \"\";\n    while (idx < code.length && fn(code[idx])) {\n      name = name + code[idx];\n      next();\n    }\n    return name;\n  }\n\n  function parse_term(ctx) {\n    // Application\n    if (match(\"(\")) {\n      var term = parse_term(ctx);\n      while (idx < code.length && !match(\")\")) {\n        var argm = parse_term(ctx);\n        var term = App(term, argm);\n        next_char();\n      }\n      return term;\n    }\n\n    // Lambda\n    else if (match(\"{\")) {\n      var names = [];\n      while (idx < code.length && !match(\"}\")) {\n        names.push(parse_string());\n      }\n      var term = parse_term(ctx.concat(names));\n      for (var i = names.length - 1; i >= 0; --i) {\n        term = Lam(names[i], term);\n      }\n      return term;\n    }\n\n    // Duplication\n    else if (match(\"dup \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var expr = parse_term(ctx);\n      var body = parse_term(ctx.concat([name]));\n      return Dup(name, expr, body);\n    }\n\n    // Put\n    else if (match(\"#\")) {\n      var expr = parse_term(ctx);\n      return Put(expr);\n    }\n\n    // Let\n    else if (match(\"let \")) {\n      var name = parse_string();\n      var skip = parse_exact(\"=\");\n      var copy = parse_term(ctx);\n      var body = parse_term(ctx.concat([name]));\n      return subst(body, copy, 0);\n    }\n\n    // Operation\n    else if (match(\"|\")) {\n      var num0 = parse_term(ctx);\n      var func = parse_string(c => !is_space(c));\n      var num1 = parse_term(ctx);\n      var skip = parse_exact(\"|\");\n      return Op2(func, num0, num1);\n    }\n\n    // String\n    else if (match(\"\\\"\")) {\n      // Parses text\n      var text = \"\";\n      while (code[idx] !== \"\\\"\") {\n        text += code[idx];\n        next();\n      }\n      next();\n      return text_to_term(text);\n    }\n\n    // Nat\n    else if (match(\"~\")) {\n      var name = parse_string();\n      var numb = Number(name);\n      return numb_to_term(numb);\n    }\n\n    // If-Then-Else\n    else if (match(\"if \")) {\n      var cond = parse_term(ctx);\n      var pair = parse_term(ctx);\n      return Ite(cond, pair);\n    }\n\n    // Copy\n    else if (match(\"cpy \")) {\n      var name = parse_string();\n      let skip = parse_exact(\"=\");\n      var numb = parse_term(ctx);\n      var body = parse_term(ctx.concat([name]));\n      return Cpy(name, numb, body);\n    }\n\n    // Pair\n    else if (match(\"[\")) {\n      var val0 = parse_term(ctx);\n      var skip = parse_exact(\",\");\n      var val1 = parse_term(ctx);\n      var skip = parse_exact(\"]\");\n      return Par(val0, val1);\n    }\n    \n    // Pair (If-Then-Else sugar)\n    else if (match(\"then:\")) {\n      var val0 = parse_term(ctx);\n      var skip = parse_exact(\"else:\");\n      var val1 = parse_term(ctx);\n      return Par(val0, val1);\n    }\n\n    // First\n    else if (match(\"fst \")) {\n      var pair = parse_term(ctx);\n      return Fst(pair);\n    }\n\n    // Second\n    else if (match(\"snd \")) {\n      var pair = parse_term(ctx);\n      return Snd(pair);\n    }\n\n    // Projection\n    else if (match(\"get \")) {\n      var skip = parse_exact(\"[\");\n      var nam0 = parse_string();\n      var skip = parse_exact(\",\");\n      var nam1 = parse_string();\n      var skip = parse_exact(\"]\");\n      var skip = parse_exact(\"=\");\n      var pair = parse_term(ctx);\n      var body = parse_term(ctx.concat([nam0, nam1]));\n      return Prj(nam0, nam1, pair, body);\n    }\n\n    // Variable / Reference\n    else {\n      var name = parse_string();\n      var numb = Number(name);\n      if (!isNaN(numb)) {\n        return Num(numb >>> 0);\n      }\n      var skip = 0;\n      while (match(\"'\")) {\n        skip += 1;\n      }\n      for (var i = ctx.length - 1; i >= 0; --i) {\n        if (ctx[i] === name) {\n          if (skip === 0) break;\n          else skip -= 1;\n        }\n      }\n      if (i === -1) {\n        return Ref(name);\n      } else {\n        return Var(ctx.length - i - 1);\n      }\n    }\n  }\n\n  var idx = 0;\n  var row = 0;\n  var col = 0;\n  var defs = {};\n  var infs = {};\n  while (idx < code.length) {\n    next_char();\n    if (match(\"inf \")) {\n      var name = parse_string();\n      var skip = parse_exact(\":\");\n      var skip = parse_exact(\"init:\");\n      var init = parse_term([]);\n      var skip = parse_exact(\"step:\");\n      var step = Lam(\"self\", parse_term([\"self\"]));\n      var skip = parse_exact(\"stop:\");\n      var stop = Lam(\"self\", parse_term([\"self\"]));\n      var skip = parse_exact(\"done:\");\n      var done = Lam(\"self\", parse_term([\"self\"]));\n      infs[name] = {init, step, stop, done};\n    } else {\n      var skip = parse_exact(\"def \");\n      var name = parse_string();\n      var skip = parse_exact(\":\");\n      var term = parse_term([]);\n      defs[name] = term;\n    }\n    next_char();\n  }\n\n  return {defs, infs};\n}\n\n// :::::::::::::::::::::\n// :: Stringification ::\n// :::::::::::::::::::::\n\n// Generates a name\nconst gen_name = (n) => {\n  var str = \"\";\n  ++n;\n  while (n > 0) {\n    --n;\n    str += String.fromCharCode(97 + n % 26);\n    n = Math.floor(n / 26);\n  }\n  return str;\n};\n\n// Converts a term to a string\nconst show = ([ctor, args], canon = false, ctx = []) => {\n  switch (ctor) {\n    case \"Var\":\n      return ctx[ctx.length - args.index - 1] || \"^\" + args.index;\n    case \"Lam\":\n      var term = [ctor, args];\n      var numb = null;\n      var names = [];\n      while (term[0] === \"Lam\") {\n        numb = term_to_numb(term);\n        if (numb !== null) {\n          break;\n        } else {\n          names.push(canon ? gen_name(ctx.length) : term[1].name);\n          term = term[1].body;\n        }\n      }\n      var head = names.length > 0 ? \"{\" + names.join(\" \") + \"} \" : \"\";\n      if (numb !== null) {\n        return head + \"~\" + Number(numb);\n      } else {\n        return head + show(term, canon, ctx.concat(names))\n      }\n    case \"App\":\n      var text = \")\";\n      var term = [ctor, args];\n      while (term[0] === \"App\") {\n        text = \" \" + show(term[1].argm, canon, ctx) + text;\n        term = term[1].func;\n      }\n      return \"(\" + show(term, canon, ctx) + text;\n    case \"Put\":\n      var expr = show(args.expr, canon, ctx);\n      return \"#\" + expr;\n    case \"Dup\":\n      var name = args.name;\n      var expr = show(args.expr, canon, ctx);\n      var body = show(args.body, canon, ctx.concat([name]));\n      return \"(dup \" + name + \" = \" + expr + \" \" + body + \")\";\n    case \"Num\":\n      return args.numb.toString();\n    case \"Op1\":\n    case \"Op2\":\n      var func = args.func;\n      var num0 = show(args.num0, canon, ctx);\n      var num1 = show(args.num1, canon, ctx);\n      return \"|\" + num0 + \" \" + func + \" \" + num1 + \"|\";\n    case \"Ite\":\n      var cond = show(args.cond, canon, ctx);\n      var pair = show(args.pair, canon, ctx);\n      return \"(if \" + cond + \" \" + pair + \")\";\n    case \"Cpy\":\n      var name = args.name;\n      var numb = show(args.numb, canon, ctx);\n      var body = show(args.body, canon, ctx.concat([name]));\n      return \"(cpy \" + name + \" = \" + numb + \" \" + body + \")\";\n    case \"Par\":\n      var text = term_to_text([ctor, args]);\n      if (text !== null) {\n        return \"\\\"\" + text + \"\\\"\";\n      } else {\n        var val0 = show(args.val0, canon, ctx);\n        var val1 = show(args.val1, canon, ctx);\n        return \"[\" + val0 + \",\" + val1 + \"]\";\n      }\n    case \"Fst\":\n      var pair = show(args.pair, canon, ctx);\n      return \"(fst \" + pair + \")\";\n    case \"Snd\":\n      var pair = show(args.pair, canon, ctx);\n      return \"(snd \" + pair + \")\";\n    case \"Prj\":\n      var nam0 = args.nam0;\n      var nam1 = args.nam1;\n      var pair = show(args.pair, canon, ctx);\n      var body = show(args.body, canon, ctx.concat([nam0, nam1]));\n      return \"(get [\" + nam0 + \",\" + nam1 + \"] = \" + pair + \" \" + body + \")\";\n    case \"Ref\":\n      return args.name;\n  }\n}\n\n// ::::::::::::::::::\n// :: Substitution ::\n// ::::::::::::::::::\n\n// Shifts a term\nconst shift = ([ctor, term], inc, depth) => {\n  switch (ctor) {\n    case \"Var\":\n      return Var(term.index < depth ? term.index : term.index + inc);\n    case \"Lam\":\n      var name = term.name;\n      var body = shift(term.body, inc, depth + 1);\n      return Lam(name, body);\n    case \"App\":\n      var func = shift(term.func, inc, depth);\n      var argm = shift(term.argm, inc, depth);\n      return App(func, argm);\n    case \"Put\":\n      var expr = shift(term.expr, inc, depth);\n      return Put(expr);\n    case \"Dup\":\n      var name = term.name;\n      var expr = shift(term.expr, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return Dup(name, expr, body);\n    case \"Num\":\n      var numb = term.numb;\n      return Num(numb);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = shift(term.num0, inc, depth);\n      var num1 = shift(term.num1, inc, depth);\n      return Op2(func, num0, num1);\n    case \"Ite\":\n      var cond = shift(term.cond, inc, depth);\n      var pair = shift(term.pair, inc, depth);\n      return Ite(cond, pair);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = shift(term.numb, inc, depth);\n      var body = shift(term.body, inc, depth + 1);\n      return Cpy(name, numb, body);\n    case \"Par\":\n      var val0 = shift(term.val0, inc, depth);\n      var val1 = shift(term.val1, inc, depth);\n      return Par(val0, val1);\n    case \"Fst\":\n      var pair = shift(term.pair, inc, depth);\n      return Fst(pair);\n    case \"Snd\":\n      var pair = shift(term.pair, inc, depth);\n      return Snd(pair);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = shift(term.pair, inc, depth);\n      var body = shift(term.body, inc, depth + 2);\n      return Prj(nam0, nam1, pair, body);\n    case \"Ref\":\n      return Ref(term.name);\n  }\n}\n\n// Substitution\nconst subst = ([ctor, term], val, depth) => {\n  switch (ctor) {\n    case \"Var\":\n      return depth === term.index ? val : Var(term.index - (term.index > depth ? 1 : 0));\n    case \"Lam\":\n      var name = term.name;\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Lam(name, body);\n    case \"App\":\n      var func = subst(term.func, val, depth);\n      var argm = subst(term.argm, val, depth);\n      return App(func, argm);\n    case \"Put\":\n      var expr = subst(term.expr, val, depth);\n      return Put(expr);\n    case \"Dup\": \n      var name = term.name;\n      var expr = subst(term.expr, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Dup(name, expr, body);\n    case \"Num\":\n      var numb = term.numb;\n      return Num(numb);\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = subst(term.num0, val, depth);\n      var num1 = subst(term.num1, val, depth);\n      return Op2(func, num0, num1);\n    case \"Ite\":\n      var cond = subst(term.cond, val, depth);\n      var pair = subst(term.pair, val, depth);\n      return Ite(cond, pair);\n    case \"Cpy\":\n      var name = term.name;\n      var numb = subst(term.numb, val, depth);\n      var body = subst(term.body, val && shift(val, 1, 0), depth + 1);\n      return Cpy(name, numb, body);\n    case \"Par\":\n      var val0 = subst(term.val0, val, depth);\n      var val1 = subst(term.val1, val, depth);\n      return Par(val0, val1);\n    case \"Fst\":\n      var pair = subst(term.pair, val, depth);\n      return Fst(pair);\n    case \"Snd\":\n      var pair = subst(term.pair, val, depth);\n      return Snd(pair);\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = subst(term.pair, val, depth);\n      var body = subst(term.body, val && shift(val, 2, 0), depth + 2);\n      return Prj(nam0, nam1, pair, body);\n    case \"Ref\":\n      var name = term.name;\n      return Ref(name);\n  }\n}\n\n// ::::::::::::::::::::\n// :: Stratification ::\n// ::::::::::::::::::::\n\n// How many times a variable was used in computational positions\nconst uses = ([ctor, term], depth = 0) => {\n  switch (ctor) {\n    case \"Var\": return term.index === depth ? 1 : 0;\n    case \"Lam\": return uses(term.body, depth + 1);\n    case \"App\": return uses(term.func, depth) + uses(term.argm, depth);\n    case \"Put\": return uses(term.expr, depth);\n    case \"Dup\": return uses(term.expr, depth) + uses(term.body, depth + 1);\n    case \"Num\": return 0;\n    case \"Op1\": return uses(term.num0, depth) + uses(term.num1, depth);\n    case \"Op2\": return uses(term.num0, depth) + uses(term.num1, depth);\n    case \"Ite\": return uses(term.cond, depth) + uses(term.pair, depth);\n    case \"Cpy\": return uses(term.numb, depth) + uses(term.body, depth + 1);\n    case \"Par\": return uses(term.val0, depth) + uses(term.val1, depth);\n    case \"Fst\": return uses(term.pair, depth);\n    case \"Snd\": return uses(term.pair, depth);\n    case \"Prj\": return uses(term.pair, depth) + uses(term.body, depth + 2);\n    case \"Ref\": return 0;\n  }\n}\n\n// Checks if variable only occurs at a specific relative level\nconst is_at_level = ([ctor, term], at_level, depth = 0, level = 0) => {\n  switch (ctor) {\n    case \"Var\": return term.index !== depth || level === at_level;\n    case \"Lam\": return is_at_level(term.body, at_level, depth + 1, level);\n    case \"App\": return is_at_level(term.func, at_level, depth, level) && is_at_level(term.argm, at_level, depth, level);\n    case \"Put\": return is_at_level(term.expr, at_level, depth, level + 1);\n    case \"Dup\": return is_at_level(term.expr, at_level, depth, level) && is_at_level(term.body, at_level, depth + 1, level);\n    case \"Num\": return true;\n    case \"Op1\": return is_at_level(term.num0, at_level, depth, level) && is_at_level(term.num1, at_level, depth, level);\n    case \"Op2\": return is_at_level(term.num0, at_level, depth, level) && is_at_level(term.num1, at_level, depth, level);\n    case \"Ite\": return is_at_level(term.cond, at_level, depth, level) && is_at_level(term.pair, at_level, depth, level);\n    case \"Cpy\": return is_at_level(term.numb, at_level, depth, level) && is_at_level(term.body, at_level, depth + 1, level);\n    case \"Par\": return is_at_level(term.val0, at_level, depth, level) && is_at_level(term.val1, at_level, depth, level);\n    case \"Fst\": return is_at_level(term.pair, at_level, depth, level);\n    case \"Snd\": return is_at_level(term.pair, at_level, depth, level);\n    case \"Prj\": return is_at_level(term.pair, at_level, depth, level) && is_at_level(term.body, at_level, depth + 2, level);\n    case \"Pri\": return is_at_level(term.argm, at_level, depth, level);\n    case \"Ref\": return true;\n  }\n}\n\n// Checks if a term is stratified\nconst check = ([ctor, term], defs = {}, ctx = []) => {\n  switch (ctor) {\n    case \"Lam\": \n      if (uses(term.body) > 1) {\n        throw \"[ERROR]\\nLambda variable `\" + term.name + \"` used more than once in:\\n\" + show([ctor, term], false, ctx);\n      }\n      if (!is_at_level(term.body, 0)) {\n        throw \"[ERROR]\\nLambda variable `\" + term.name + \"` used inside a box in:\\n\" + show([ctor, term], false, ctx);\n      }\n      check(term.body, defs, ctx.concat([term.name]));\n      break;\n    case \"App\":\n      check(term.func, defs, ctx);\n      check(term.argm, defs, ctx);\n      break;\n    case \"Put\":\n      check(term.expr, defs, ctx);\n      break;\n    case \"Dup\":\n      if (!is_at_level(term.body, 1)) {\n        throw \"[ERROR]\\nDuplication variable `\" + term.name + \"` must always have exactly 1 enclosing box on the body of:\\n\" + show([ctor, term], false, ctx);\n      }\n      check(term.expr, defs, ctx);\n      check(term.body, defs, ctx.concat([term.name]));\n      break;\n    case \"Op1\":\n    case \"Op2\":\n      check(term.num0, defs, ctx);\n      check(term.num1, defs, ctx);\n      break;\n    case \"Ite\":\n      check(term.cond, defs, ctx);\n      check(term.pair, defs, ctx);\n      break;\n    case \"Cpy\":\n      check(term.numb, defs, ctx);\n      check(term.body, defs, ctx.concat([term.name]));\n      break;\n    case \"Par\":\n      check(term.val0, defs, ctx);\n      check(term.val1, defs, ctx);\n      break;\n    case \"Fst\":\n      check(term.pair, defs, ctx);\n      break;\n    case \"Snd\":\n      check(term.pair, defs, ctx);\n      break;\n    case \"Prj\":\n      var uses0 = uses(term.body, 1);\n      var uses1 = uses(term.body, 0);\n      var isat0 = is_at_level(term.body, 0, 1);\n      var isat1 = is_at_level(term.body, 0, 0);\n      if (uses0 > 1 || uses1 > 1) {\n        throw \"[ERROR]\\nProjection variable `\" + (uses0 > 1 ? term.nam0 : term.nam1) + \"` used more than once in:\\n\" + show([ctor, term], false, ctx);\n      }\n      if (!isat0 || !isat1) {\n        throw \"[ERROR]\\nProjection variable `\" + (!isat0 ? term.nam0 : term.nam1) + \"` used inside a box in:\\n\" + show([ctor, term], false, ctx);\n      }\n      check(term.pair, defs, ctx);\n      check(term.body, defs, ctx.concat([term.nam0, term.nam1]));\n      break;\n    case \"Ref\":\n      if (!defs[term.name]) {\n        throw \"[ERROR]\\nUndefined reference: \" + term.name;\n      } else {\n        check(defs[term.name], defs, ctx);\n        break;\n      }\n  }\n}\n\n// ::::::::::::::::\n// :: Evaluation ::\n// ::::::::::::::::\n\n// Reduces a term to normal form or head normal form\nconst norm = (term, defs = {}, to_lam = false) => {\n  var [ctor, term] = term;\n  const apply = (func, argm) => {\n    var func = norm(func, defs, to_lam);\n    // ([x]a b) ~> [b/x]a\n    if (func[0] === \"Lam\") {\n      return norm(subst(func[1].body, argm, 0), defs, to_lam);\n    // ([x = a] b c) ~> [x = a] (b c)\n    } else if (func[0] === \"Dup\") {\n      return norm(Dup(func[1].name, func[1].expr, App(func[1].body, shift(argm, 1, 0))), defs, to_lam);\n    // (|a b) ~> ⊥\n    } else if (func[0] === \"Put\") {\n      throw \"[RUNTIME-ERROR]\\nCan't apply a boxed value.\";\n    } else {\n      return App(norm(func, defs, to_lam), norm(argm, defs, to_lam));\n    }\n  }\n  const duplicate = (name, expr, body) => {\n    var expr = norm(expr, defs, to_lam);\n    // [x = |a] b ~> [a/x]b\n    if (expr[0] === \"Put\") {\n      return norm(subst(body, expr[1].expr, 0), defs, to_lam);\n    // [x = [y = a] b] c ~> [y = a] [x = b] c\n    } else if (expr[0] === \"Dup\") {\n      return norm(Dup(expr[1].name, expr[1].expr, Dup(name, expr[1].body, shift(body, 1, 1))), defs, to_lam); \n    // [x = [y] b] c ~> ⊥\n    } else if (expr[0] === \"Lam\") {\n      throw \"[RUNTIME-ERROR]\\nCan't duplicate a lambda.\";\n    } else {\n      return Dup(name, expr, norm(body, defs, to_lam));\n    }\n  }\n  const dereference = (name) => {\n    if (defs[name]) {\n      return norm(defs[name], defs, to_lam);\n    } else {\n      return Ref(name);\n    }\n  }\n  const op1 = (func, num0, num1) => {\n    var num0 = norm(num0, defs, to_lam);\n    if (num0[0] === \"Num\") {\n      switch (func) {\n        case \"+\"  : return Num((num0[1].numb + num1[1].numb) >>> 0);\n        case \"-\"  : return Num((num0[1].numb - num1[1].numb) >>> 0);\n        case \"*\"  : return Num((num0[1].numb * num1[1].numb) >>> 0);\n        case \"/\"  : return Num((num0[1].numb / num1[1].numb) >>> 0);\n        case \"%\"  : return Num((num0[1].numb % num1[1].numb) >>> 0);\n        case \"**\" : return Num((num0[1].numb ** num1[1].numb) >>> 0);\n        case \"^^\" : return Num((num0[1].numb ** (num1[1].numb / (2 ** 32))) >>> 0);\n        case \"&\"  : return Num((num0[1].numb & num1[1].numb) >>> 0);\n        case \"|\"  : return Num((num0[1].numb | num1[1].numb) >>> 0);\n        case \"^\"  : return Num((num0[1].numb ^ num1[1].numb) >>> 0);\n        case \"~\"  : return Num((~ num1[1].numb) >>> 0);\n        case \">>\" : return Num((num0[1].numb >>> num1[1].numb) >>> 0);\n        case \"<<\" : return Num((num0[1].numb << num1[1].numb) >>> 0);\n        case \">\"  : return Num((num0[1].numb > num1[1].numb ? 1 : 0) >>> 0);\n        case \"<\"  : return Num((num0[1].numb < num1[1].numb ? 1 : 0) >>> 0);\n        case \"==\" : return Num((num0[1].numb === num1[1].numb ? 1 : 0) >>> 0);\n        default   : throw \"[RUNTIME-ERROR]\\nUnknown primitive: \" + func + \".\";\n      }\n    } else {\n      return Op1(func, num0, norm(num1, defs, to_lam));\n    }\n  }\n  const op2 = (func, num0, num1) => {\n    var num1 = norm(num1, defs, to_lam);\n    if (num1[0] === \"Num\") {\n      return norm(Op1(func, num0, num1), defs, to_lam);\n    } else {\n      return Op2(func, norm(num0, defs, to_lam), num1);\n    }\n  }\n  const if_then_else = (cond, pair) => {\n    var cond = norm(cond, defs, to_lam);\n    if (cond[0] === \"Num\") {\n      return norm(cond[1].numb > 0 ? Fst(pair) : Snd(pair), defs, to_lam);\n    } else {\n      return Ite(cond, norm(pair, defs, to_lam));\n    }\n  }\n  const copy = (name, numb, body) => {\n    var numb = norm(numb, defs, to_lam);\n    if (numb[0] === \"Num\") {\n      return norm(subst(body, numb, 0), defs, to_lam);\n    } else {\n      return Cpy(name, numb, norm(body, defs, to_lam));\n    }\n  }\n  const first = (pair) => {\n    var pair = norm(pair, defs, to_lam);\n    if (pair[0] === \"Par\") {\n      return norm(pair[1].val0, defs, to_lam);\n    } else {\n      return Fst(pair);\n    }\n  }\n  const second = (pair) => {\n    var pair = norm(pair, defs, to_lam);\n    if (pair[0] === \"Par\") {\n      return norm(pair[1].val1, defs, to_lam);\n    } else {\n      return Snd(pair);\n    }\n  }\n  const case_of = (nam0, nam1, pair, body) => {\n    var pair = norm(pair, defs, to_lam);\n    if (pair[0] === \"Par\") {\n      return norm(subst(subst(body, shift(pair[1].val0, 1, 0), 1), pair[1].val1, 0), defs, to_lam);\n    } else {\n      return Prj(nam0, nam1, pair, norm(body, defs, to_lam));\n    }\n  }\n  if (to_lam && ctor === \"Put\") {\n    return norm(term.expr, defs, to_lam);\n  } else if (to_lam && ctor === \"Dup\") {\n    return norm(subst(term.body, term.expr, 0), defs, to_lam)\n  } else if (to_lam && ctor === \"Prj\") {\n    return norm(subst(subst(term.body, Fst(shift(term.pair, 1, 0)), 1), Snd(term.pair), 0), defs, to_lam);\n  } else if (to_lam && ctor === \"Cpy\") {\n    return norm(subst(term.body, term.numb, 0), defs, to_lam)\n  } else {\n    switch (ctor) {\n      case \"Var\": return Var(term.index);\n      case \"Lam\": return Lam(term.name, norm(term.body, defs, to_lam)); \n      case \"App\": return apply(term.func, term.argm);\n      case \"Put\": return Put(norm(term.expr, defs, to_lam));\n      case \"Dup\": return duplicate(term.name, term.expr, term.body);\n      case \"Num\": return Num(term.numb);\n      case \"Op1\": return op1(term.func, term.num0, term.num1);\n      case \"Op2\": return op2(term.func, term.num0, term.num1);\n      case \"Ite\": return if_then_else(term.cond, term.pair);\n      case \"Cpy\": return copy(term.name, term.numb, term.body);\n      case \"Par\": return Par(norm(term.val0, defs, to_lam), norm(term.val1, defs, to_lam));\n      case \"Fst\": return first(term.pair);\n      case \"Snd\": return second(term.pair);\n      case \"Prj\": return case_of(term.nam0, term.nam1, term.pair, term.body);\n      case \"Ref\": return dereference(term.name);\n    }\n  }\n}\n\n// ::::::::::::::\n// :: Equality ::\n// ::::::::::::::\n\n// Checks if two terms are equal\nconst equal = ([a_ctor, a_term], [b_ctor, b_term]) => {\n  switch (a_ctor + \"-\" + b_ctor) {\n    case \"var-var\": return a_term.index === b_term.index;\n    case \"lam-lam\": return equal(a_term.body, b_term.body);\n    case \"app-app\": return equal(a_term.func, b_term.func) && equal(a_term.argm, b_term.argm);\n    case \"put-put\": return equal(a_term.expr, b_term.expr);\n    case \"dup-dup\": return equal(a_term.expr, b_term.expr) && equal(a_term.body, b_term.body);\n    case \"ref-ref\": return a_term.name === b_term.name;\n    case \"num-num\": return a_term.numb === b_term.numb;\n    case \"op1-op1\": return a_term.func === b_term.func && equal(a_term.num0, b_term.num0) && a_term.num1 === a_term.num1;\n    case \"op2-op2\": return a_term.func === b_term.func && equal(a_term.num0, b_term.num0) && equal(a_term.num1, b_term.num1);\n    case \"ite-ite\": return equal(a_term.cond, b_term.cond) && equal(a_term.pair, b_term.pair);\n    case \"cpy-cpy\": return equal(a_term.numb, b_term.numb) && equal(a_term.body, b_term.body);\n    case \"par-par\": return equal(a_term.val0, b_term.val0) && equal(a_term.val1, b_term.val1);\n    case \"fst-fst\": return equal(a_term.pair, b_term.pair);\n    case \"snd-snd\": return equal(a_term.pair, b_term.pair);\n    case \"cas-cas\": return equal(a_term.pair, b_term.pair) && equal(a_term.body, b_term.body);\n    default: return false;\n  }\n}\n\n// :::::::::::::::::::\n// :: Syntax Sugars ::\n// :::::::::::::::::::\n\n// Converts an utf-8 string to a λ-encoded term\nconst text_to_term = (text) => {\n  // Converts UTF-8 to bytes\n  var bytes = [].slice.call(new TextEncoder(\"utf-8\").encode(text), 0);\n\n  // Converts bytes to uints\n  while (bytes.length % 4 !== 0) {\n    bytes.push(0);\n  }\n  var nums = new Uint32Array(new Uint8Array(bytes).buffer);\n\n  // Converts uints to C-List of nums\n  var term = Var(0);\n  for (var i = nums.length - 1; i >= 0; --i) {\n    term = App(App(Var(1), Num(nums[i])), term);\n  }\n  term = Par(Num(0x74786574), Lam(\"c\", Dup(\"c\", Var(0), Put(Lam(\"n\", term)))));\n  return term;\n}\n\n// Converts a λ-encoded term to a string, if possible\nconst term_to_text = (term) => {\n  try {\n    if (term[1].val0[1].numb === 0x74786574) {\n      try {\n        term = term[1].val1[1].body[1].body[1].expr[1].body;\n      } catch(e) {\n        term = term[1].val1[1].body[1].body;\n      }\n      var nums = [];\n      while (term[0] !== \"Var\") {\n        if (term[1].func[1].func[1].index !== 1) {\n          return null;\n        }\n        nums.push(term[1].func[1].argm[1].numb);\n        term = term[1].argm;\n      }\n      if (term[1].index !== 0) {\n        return null;\n      }\n      return new TextDecoder(\"utf-8\").decode(new Uint8Array(new Uint32Array(nums).buffer));\n    } else {\n      return null;\n    }\n  } catch (e) {\n    return null;\n  }\n}\n\n// Converts a number to a λ-encoded nat for repeated application (bounded for-loop)\nconst numb_to_term = (numb) => {\n  var term = Var(0);\n  var log2 = Math.floor(Math.log(numb) / Math.log(2));\n  for (var i = 0; i < log2 + 1; ++i) {\n    term = (numb >>> (log2 - i)) & 1 ? App(Var(i + 1), term) : term;\n  }\n  term = Put(Lam(\"x\", term));\n  for (var i = 0; i < log2; ++i) {\n    term = Dup(\"s\" + (log2 - i), Put(Lam(\"x\", App(Var(1), App(Var(1), Var(0))))), term);\n  }\n  term = Lam(\"s\", Dup(\"s0\", Var(0), term));\n  return term;\n}\n\n// Converts a λ-encoded nat to a number, if possible\nconst term_to_numb = (term) => {\n  try {\n    try {\n      term = term[1].body[1].body[1].expr[1].body;\n    } catch(e) {\n      term = term[1].body[1].body;\n    }\n    var count = 0;\n    while (term[0] !== \"Var\") {\n      if (term[1].func[1].index !== 1) {\n        return null;\n      }\n      count++;\n      term = term[1].argm;\n    }\n    if (term[1].index !== 0) {\n      return null;\n    }\n    return count;\n  } catch (e) {\n    return null;\n  }\n}\n\nmodule.exports = {\n  Var, Ref, Lam, App, Put,\n  Dup, Num, Op1, Op2, Ite,\n  Cpy, Par, Fst, Snd, Prj,\n  gen_name,\n  parse,\n  show,\n  check,\n  norm,\n  equal\n};\n\n\n//# sourceURL=webpack:///./node_modules/formality-core/fm-core.js?");

/***/ }),

/***/ "./node_modules/formality-core/fm-to-js.js":
/*!*************************************************!*\
  !*** ./node_modules/formality-core/fm-to-js.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const fmc = __webpack_require__(/*! ./fm-core.js */ \"./node_modules/formality-core/fm-core.js\");\n\n// Converts a Formality-Core Term to a native JavaScript function\nconst compile = ([ctor, term], defs, vars) => {\n  switch (ctor) {\n    case \"Var\":\n      for (var i = 0; i < term.index; ++i) {\n        vars = vars[1];\n      }\n      return vars[0];\n    case \"Lam\":\n      return x => compile(term.body, defs, [x, vars]);\n    case \"App\":\n      var func = compile(term.func, defs, vars);\n      var argm = compile(term.argm, defs, vars);\n      return func(argm);\n    case \"Put\":\n      return compile(term.expr, defs, vars);\n    case \"Dup\": \n      var expr = compile(term.expr, defs, vars);\n      var body = x => compile(term.body, defs, [x,vars]);\n      return body(expr);\n    case \"Num\":\n      return term.numb;\n    case \"Op1\":\n    case \"Op2\":\n      var func = term.func;\n      var num0 = compile(term.num0, defs, vars);\n      var num1 = compile(term.num1, defs, vars);\n      switch (func) {\n        case \"+\"  : return (num0 + num1) >>> 0;\n        case \"-\"  : return (num0 - num1) >>> 0;\n        case \"*\"  : return (num0 * num1) >>> 0;\n        case \"/\"  : return (num0 / num1) >>> 0;\n        case \"%\"  : return (num0 % num1) >>> 0;\n        case \"**\" : return (num0 ** num1) >>> 0;\n        case \"^^\" : return (num0 ** (num1 / (2 ** 32))) >>> 0;\n        case \"&\"  : return (num0 & num1) >>> 0;\n        case \"|\"  : return (num0 | num1) >>> 0;\n        case \"^\"  : return (num0 ^ num1) >>> 0;\n        case \"~\"  : return (~ num1) >>> 0;\n        case \">>\" : return (num0 >>> num1) >>> 0;\n        case \"<<\" : return (num0 << num1) >>> 0;\n        case \">\"  : return (num0 > num1) >>> 0;\n        case \"<\"  : return (num0 < num1) >>> 0;\n        case \"==\" : return (num0 === num1) >>> 0;\n      }\n    case \"Ite\":\n      var cond = compile(term.cond, defs, vars);\n      var pair = compile(term.pair, defs, vars);\n      return cond ? pair[0] : pair[1];\n    case \"Cpy\":\n      var numb = compile(term.numb, defs, vars);\n      var body = x => compile(term.body, defs, [x,vars]);\n      return body(numb);\n    case \"Par\":\n      var val0 = compile(term.val0, defs, vars);\n      var val1 = compile(term.val1, defs, vars);\n      return [val0, val1];\n    case \"Fst\":\n      var pair = compile(term.pair, defs, vars);\n      return pair[0];\n    case \"Snd\":\n      var pair = compile(term.pair, defs, vars);\n      return pair[1];\n    case \"Prj\":\n      var nam0 = term.nam0;\n      var nam1 = term.nam1;\n      var pair = compile(term.pair, defs, vars);\n      var body = (x,y) => compile(term.body, defs, [y,[x,vars]]);\n      return body(pair[0], pair[1]);\n    case \"Ref\":\n      return compile(defs[term.name], defs, vars);\n  }\n};\n\n// Converts a native JavaScript function back to a Formality-Core term\nconst decompile = (func) => {\n  return (function go(term, depth) {\n    function APP(variable) {\n      return function FMC_DECOMPILE_GET(arg){\n        if (arg === null) {\n          return variable;\n        } else {\n          return APP(d => fmc.App(variable(d), go(arg, d)));\n        }\n      };\n    };\n    function VAR(d) {\n      return fmc.Var(d - 1 - depth);\n    };\n    if (typeof term === \"function\" && term.name === \"FMC_DECOMPILE_GET\") {\n      return term(null)(depth);\n    } else if (typeof term === \"object\") {\n      var val0 = go(term[0], depth);\n      var val1 = go(term[1], depth);\n      return fmc.Par(val0, val1);\n    } else if (typeof term === \"number\") {\n      return fmc.Num(term);\n    } else if (typeof term === \"function\") {\n      var body = go(term(APP(VAR)), depth + 1);\n      return fmc.Lam(fmc.gen_name(depth), body);\n    } else if (typeof term === \"string\") {\n      throw \"[ERROR]\\nThis native JS function can't be decompiled to FMC:\\n\\n\"\n        + func.toString()\n        + \"\\n\\nIt possibly uses numeric operators on free variables, which can't be decompiled yet.\";\n    } else {\n      return term;\n    }\n  })(func, 0);\n};\n\nmodule.exports = {compile, decompile};\n\n\n//# sourceURL=webpack:///./node_modules/formality-core/fm-to-js.js?");

/***/ }),

/***/ "./node_modules/formality-core/fm-to-net.js":
/*!**************************************************!*\
  !*** ./node_modules/formality-core/fm-to-net.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ~~ Compiles Formality Core to Formality Net ~~\n\nconst {Var, App, Lam, Num, Op1, Op2, Ite, Par, Fst, Snd, gen_name} = __webpack_require__(/*! ./fm-core.js */ \"./node_modules/formality-core/fm-core.js\");\nconst {Net, Pointer, Numeric, addr_of, slot_of, type_of, numb_of, NOD, OP1, OP2, NUM, ITE, PTR, FOR} = __webpack_require__(/*! formality-net */ \"./node_modules/formality-net/fm-net.js\");\n\nconst op_kind = {\n   0 : \"+\"  , \"+\"  : 0, \n   1 : \"-\"  , \"-\"  : 1, \n   2 : \"*\"  , \"*\"  : 2, \n   3 : \"/\"  , \"/\"  : 3, \n   4 : \"%\"  , \"%\"  : 4,\n   5 : \"**\" , \"**\" : 5,\n   6 : \"^^\" , \"^^\" : 6,\n   7 : \"&\"  , \"&\"  : 7,\n   8 : \"|\"  , \"|\"  : 8,\n   9 : \"^\"  , \"^\"  : 9,\n  10 : \"~\"  , \"~\"  : 10,\n  11 : \">>\" , \">>\" : 11,\n  12 : \"<<\" , \"<<\" : 12,\n  13 : \">\"  , \">\"  : 13,\n  14 : \"<\"  , \"<\"  : 14,\n  15 : \"==\" , \"==\"  : 15,\n};\n\nconst compile = (term, defs = {}) => {\n  const build_net = (term, net, var_ptrs, level) => {\n    const get_var = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return ptrn;\n      } else {\n        if (net.enter_port(ptrn) === ptrn) {\n          return ptrn;\n        } else {\n          var dups_ptrn = net.enter_port(ptrn);\n          var dup_addr = net.alloc_node(NOD, level_of[ptrn] + 1);\n          net.link_ports(Pointer(dup_addr, 0), ptrn);\n          net.link_ports(Pointer(dup_addr, 1), dups_ptrn);\n          return Pointer(dup_addr, 2);\n        }\n      }\n    };\n    switch (term[0]) {\n      case \"Dup\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level);\n        level_of[expr_ptr] = level;\n        var_ptrs.push(expr_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Put\":\n        var expr_ptr = build_net(term[1].expr, net, var_ptrs, level + 1);\n        return expr_ptr;\n      case \"Lam\":\n        var lam_addr = net.alloc_node(NOD, 0);\n        net.link_ports(Pointer(lam_addr, 1), Pointer(lam_addr, 1));\n        level_of[Pointer(lam_addr, 1)] = level;\n        var_ptrs.push(Pointer(lam_addr, 1));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        net.link_ports(Pointer(lam_addr, 2), body_ptr);\n        return Pointer(lam_addr, 0);\n      case \"App\":\n        var app_addr = net.alloc_node(NOD, 0);\n        var func_ptr = build_net(term[1].func, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 0), func_ptr);\n        var argm_ptr = build_net(term[1].argm, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 1), argm_ptr)\n        return Pointer(app_addr, 2);\n      case \"Num\":\n        return Numeric(term[1].numb >>> 0);\n      case \"Op1\":\n        var op1_addr = net.alloc_node(OP1, op_kind[term[1].func]);\n        net.link_ports(Numeric(term[1].num1[1].numb), Pointer(op1_addr, 1));\n        var num0_ptr = build_net(term[1].num0, net, var_ptrs, level);\n        net.link_ports(num0_ptr, Pointer(op1_addr, 0));\n        return Pointer(op1_addr, 2);\n      case \"Op2\":\n        var op2_addr = net.alloc_node(OP2, op_kind[term[1].func]);\n        var num0_ptr = build_net(term[1].num0, net, var_ptrs, level);\n        net.link_ports(Pointer(op2_addr, 1), num0_ptr);\n        var num1_ptr = build_net(term[1].num1, net, var_ptrs, level);\n        net.link_ports(Pointer(op2_addr, 0), num1_ptr);\n        return Pointer(op2_addr, 2);\n      case \"Par\":\n        var par_addr = net.alloc_node(NOD, 0xFFFF);\n        var val0_ptr = build_net(term[1].val0, net, var_ptrs, level);\n        net.link_ports(Pointer(par_addr, 1), val0_ptr);\n        var val1_ptr = build_net(term[1].val1, net, var_ptrs, level);\n        net.link_ports(Pointer(par_addr, 2), val1_ptr);\n        return Pointer(par_addr, 0);\n      case \"Fst\":\n        var fst_addr = net.alloc_node(NOD, 0xFFFF);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(fst_addr, 0), pair_ptr);\n        net.link_ports(Pointer(fst_addr, 2), Pointer(fst_addr, 2));\n        return Pointer(fst_addr, 1);\n      case \"Snd\":\n        var snd_addr = net.alloc_node(NOD, 0xFFFF);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(snd_addr, 0), pair_ptr);\n        net.link_ports(Pointer(snd_addr, 1), Pointer(snd_addr, 1));\n        return Pointer(snd_addr, 2);\n      case \"Prj\":\n        var prj_addr = net.alloc_node(NOD, 0xFFFF);\n        level_of[Pointer(prj_addr, 1)] = level;\n        level_of[Pointer(prj_addr, 2)] = level;\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        var_ptrs.push(Pointer(prj_addr, 1));\n        var_ptrs.push(Pointer(prj_addr, 2));\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        var_ptrs.pop();\n        net.link_ports(Pointer(prj_addr, 0), pair_ptr);\n        return body_ptr;\n      case \"Ite\":\n        var ite_addr = net.alloc_node(ITE, 0xFFFF);\n        var cond_ptr = build_net(term[1].cond, net, var_ptrs, level);\n        net.link_ports(Pointer(ite_addr, 0), cond_ptr);\n        var pair_ptr = build_net(term[1].pair, net, var_ptrs, level);\n        net.link_ports(Pointer(ite_addr, 1), pair_ptr);\n        return Pointer(ite_addr, 2);\n      case \"Cpy\":\n        var numb_ptr = build_net(term[1].numb, net, var_ptrs, level);\n        level_of[numb_ptr] = 0xFFFE;\n        var_ptrs.push(numb_ptr);\n        var body_ptr = build_net(term[1].body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Var\":\n        return get_var(var_ptrs[var_ptrs.length - term[1].index - 1]);\n      case \"Ref\":\n        return build_net(defs[term[1].name], net, var_ptrs, level);\n      default:\n        return build_net(Lam(\"\", null, Var(0)), net, var_ptrs, level);\n    }\n  };\n  var level_of = {};\n  var net = new Net();\n  var root_addr = net.alloc_node(NOD, 0);\n  var term_ptr = build_net(term, net, [], 0);\n  net.link_ports(Pointer(root_addr, 0), Pointer(root_addr, 2));\n  net.link_ports(Pointer(root_addr, 1), term_ptr);\n  // Removes invalid redexes. They can be created by the\n  // compiler when duplicating variables more than once.\n  net.redex = net.redex.filter((a_addr) => {\n    var b_ptrn = net.enter_port(Pointer(a_addr, 0));\n    if (type_of(b_ptrn) !== NUM) {\n      var b_addr = addr_of(b_ptrn);\n      var a_p0 = Pointer(a_addr, 0);\n      var b_p0 = Pointer(b_addr, 0);\n      var a_ok = net.enter_port(a_p0) === b_p0;\n      var b_ok = net.enter_port(b_p0) === a_p0;\n      return a_ok && b_ok;\n    } else {\n      return true;\n    }\n  });\n  return net;\n};\n\nconst decompile = (net) => {\n  const build_term = (net, ptrn, var_ptrs, dup_exit) => {\n    if (type_of(ptrn) === NUM) {\n      return Num(numb_of(ptrn));\n    } else {\n      var addr = addr_of(ptrn);\n      var type = net.type_of(addr);\n      var kind = net.kind_of(addr);\n      if (type === NOD) {\n        if (kind === 0) {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var_ptrs.push(Pointer(addr, 1));\n              var body = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n              var_ptrs.pop();\n              return Lam(gen_name(var_ptrs.length), body);\n            case 1:\n              for (var index = 0; index < var_ptrs.length; ++index) {\n                if (var_ptrs[var_ptrs.length - index - 1] === ptrn) {\n                  return Var(index);\n                }\n              }\n            case 2:\n              var argm = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n              var func = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return App(func, argm);\n          }\n        } else if (kind === 0xFFFF) {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var val0 = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n              var val1 = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n              return Par(val0, val1);\n            case 1:\n              var pair = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return Fst(pair);\n            case 2:\n              var pair = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              return Snd(pair);\n          }\n        } else {\n          switch (slot_of(ptrn)) {\n            case 0:\n              var exit = dup_exit.pop();\n              var term = build_term(net, net.enter_port(Pointer(addr, exit)), var_ptrs, dup_exit);\n              dup_exit.push(exit);\n              return term;\n            default:\n              dup_exit.push(slot_of(ptrn));\n              var term = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n              dup_exit.pop();\n              return term;\n          }\n        }\n      } else if (type === OP1) {\n        var num0 = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        var num1 = Num(numb_of(net.enter_port(Pointer(addr, 1))));\n        return Op1(op_kind[kind], num0, num1);\n      } else if (type === OP2) {\n        var num0 = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n        var num1 = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        return Op2(op_kind[kind], num0, num1);\n      } else if (type === ITE) {\n        var cond = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n        var pair = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n        return Ite(cond, pair);\n      }\n    }\n  };\n  return build_term(net, net.enter_port(Pointer(0, 1)), [], []);\n};\n\nconst norm_with_stats = (term, defs = {}, lazy = true) => {\n  var net = compile(term, defs);\n  var stats = lazy ? net.reduce_lazy() : net.reduce();\n  var norm = decompile(net);\n  return {norm, stats};\n};\n\nconst norm = (term, defs, lazy) => {\n  return norm_with_stats(term, defs, lazy).norm;\n};\n\nmodule.exports = {compile, decompile, norm_with_stats, norm};\n\n\n//# sourceURL=webpack:///./node_modules/formality-core/fm-to-net.js?");

/***/ }),

/***/ "./node_modules/formality-net/fm-net.js":
/*!**********************************************!*\
  !*** ./node_modules/formality-net/fm-net.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ~~ Formality Interaction Net System ~~\n\nconst Pointer = (addr, port) => (addr << 2) + (port & 3);\nconst addr_of = (ptr) => ptr >>> 2;\nconst slot_of = (ptr) => ptr & 3;\nconst Numeric = (numb) => numb + 0x100000000;\nconst numb_of = (numb) => numb - 0x100000000;\nconst type_of = (ptrn) => ptrn >= 0x100000000 ? NUM : PTR;\n\n// PtrNum types\nconst PTR = 0;\nconst NUM = 1;\n\n// Node types\nconst NOD = 0;\nconst OP1 = 1;\nconst OP2 = 2;\nconst ITE = 3;\n\nclass Net {\n  // A net stores nodes (this.nodes), reclaimable memory addrs (this.freed) and active pairs (this.redex)\n  constructor() {\n    this.nodes = []; // nodes\n    this.freed = []; // integers\n    this.redex = []; // array of (integer, integer) tuples representing addrs\n    this.find_redex = true;\n  }\n\n  // Allocates a new node, return its addr\n  alloc_node(type, kind) {\n\n    // If there is reclaimable memory, use it\n    if (this.freed.length > 0) {\n      var addr = this.freed.pop();\n\n    // Otherwise, extend the array of nodes\n    } else {\n      var addr = this.nodes.length / 4;\n    }\n\n    // Fill the memory with an empty node without pointers\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = (kind << 6) + ((type & 0x7) << 3);\n    return addr;\n  }\n\n  // Deallocates a node, allowing its space to be reclaimed\n  free_node(addr) {\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = 0;\n    this.freed.push(addr);\n  }\n\n  is_free(addr) {\n    return this.nodes[addr * 4 + 0] === addr * 4 + 0\n        && this.nodes[addr * 4 + 1] === addr * 4 + 1\n        && this.nodes[addr * 4 + 2] === addr * 4 + 2\n        && this.nodes[addr * 4 + 3] === 0;\n  }\n\n  // Returns if given slot holds a number\n  is_numeric(addr, slot) {\n    return (this.nodes[addr * 4 + 3] >>> slot) & 1; \n  }\n\n  set_port(addr, slot, ptrn) {\n    if (type_of(ptrn) === NUM) {\n      this.nodes[addr * 4 + slot] = numb_of(ptrn);\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] | (1 << slot);\n    } else {\n      this.nodes[addr * 4 + slot] = ptrn;\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] & ~(1 << slot);\n    }\n  }\n\n  get_port(addr, slot) {\n    return this.nodes[addr * 4 + slot] + (this.is_numeric(addr, slot) ? 0x100000000 : 0);\n  }\n\n  type_of(addr) {\n    return (this.nodes[addr * 4 + 3] >>> 3) & 0x7;\n  }\n\n  set_type(addr, type) {\n    this.nodes[addr * 4 + 3] = (this.nodes[addr * 4 + 3] & ~0b111000) | (type << 3);\n  }\n\n  kind_of(addr) {\n    return this.nodes[addr * 4 + 3] >>> 6;\n  }\n\n  // Given a pointer to a port, returns a pointer to the opposing port\n  enter_port(ptrn) {\n    if (type_of(ptrn) === NUM) { \n      throw \"Can't enter a numeric pointer.\";\n    } else {\n      return this.get_port(addr_of(ptrn), slot_of(ptrn));\n    }\n  }\n\n  // Connects two ports\n  link_ports(a_ptrn, b_ptrn) {\n    var a_numb = type_of(a_ptrn) === NUM;\n    var b_numb = type_of(b_ptrn) === NUM;\n\n    // Point ports to each-other\n    if (!a_numb) this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), b_ptrn);\n    if (!b_numb) this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), a_ptrn);\n\n    // If both are main ports, add this to the list of active pairs\n    if (this.find_redex && !(a_numb && b_numb) && (a_numb || slot_of(a_ptrn) === 0) && (b_numb || slot_of(b_ptrn) === 0)) {\n      this.redex.push(a_numb ? addr_of(b_ptrn) : addr_of(a_ptrn));\n    }\n  }\n\n  // Disconnects a port, causing both sides to point to themselves\n  unlink_port(a_ptrn) {\n    if (type_of(a_ptrn) === PTR) {\n      var b_ptrn = this.enter_port(a_ptrn);\n      if (type_of(b_ptrn) === PTR && this.enter_port(b_ptrn) === a_ptrn) {\n        this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), a_ptrn);\n        this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), b_ptrn);\n      }\n    }\n  }\n\n  // Rewrites an active pair\n  rewrite(a_addr) {\n    var a_ptrn = Pointer(a_addr, 0);\n    var b_ptrn = this.get_port(a_addr, 0);\n    if (type_of(b_ptrn) === NUM) {\n      var a_type = this.type_of(a_addr);\n      var a_kind = this.kind_of(a_addr);\n\n      // UnaryOperation\n      if (a_type === OP1) {\n        var dst = this.enter_port(Pointer(a_addr, 2));\n        var fst = numb_of(b_ptrn);\n        var snd = numb_of(this.enter_port(Pointer(a_addr, 1)));\n        switch (a_kind) {\n          case  0: var res = Numeric((fst + snd) >>> 0); break;\n          case  1: var res = Numeric((fst - snd) >>> 0); break;\n          case  2: var res = Numeric((fst * snd) >>> 0); break;\n          case  3: var res = Numeric((fst / snd) >>> 0); break;\n          case  4: var res = Numeric((fst % snd) >>> 0); break;\n          case  5: var res = Numeric((fst ** snd) >>> 0); break;\n          case  6: var res = Numeric((fst ** (snd / (2 ** 32)) >>> 0)); break;\n          case  7: var res = Numeric((fst & snd) >>> 0); break;\n          case  8: var res = Numeric((fst | snd) >>> 0); break;\n          case  9: var res = Numeric((fst ^ snd) >>> 0); break;\n          case 10: var res = Numeric((~snd) >>> 0); break;\n          case 11: var res = Numeric((fst >>> snd) >>> 0); break;\n          case 12: var res = Numeric((fst << snd) >>> 0); break;\n          case 13: var res = Numeric((fst > snd ? 1 : 0) >>> 0); break;\n          case 14: var res = Numeric((fst < snd ? 1 : 0) >>> 0); break;\n          case 15: var res = Numeric((fst == snd ? 1 : 0) >>> 0); break;\n          default: throw \"[ERROR]\\nInvalid interaction.\";\n        }\n        this.link_ports(dst, res);\n        this.unlink_port(Pointer(a_addr, 0));\n        this.unlink_port(Pointer(a_addr, 2));\n        this.free_node(a_addr);\n      \n      // BinaryOperation\n      } else if (a_type === OP2) {\n        this.set_type(a_addr, OP1);\n        this.link_ports(Pointer(a_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.unlink_port(Pointer(a_addr, 1));\n        this.link_ports(Pointer(a_addr, 1), b_ptrn);\n    \n      // NumberDuplication\n      } else if (a_type === NOD) {\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 2)));\n        this.free_node(a_addr);\n\n      // IfThenElse\n      } else if (a_type === ITE) {\n        var pair_ptr = this.enter_port(Pointer(a_addr, 1));\n        var dest_ptr = this.enter_port(Pointer(a_addr, 2));\n        var cond_val = numb_of(b_ptrn) === 0;\n        this.set_type(a_addr, NOD);\n        this.link_ports(Pointer(a_addr, 0), pair_ptr);\n        this.link_ports(Pointer(a_addr, cond_val ? 1 : 2), Pointer(a_addr, cond_val ? 1 : 2));\n        this.link_ports(Pointer(a_addr, cond_val ? 2 : 1), dest_ptr);\n\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n\n    } else {\n      var b_addr = addr_of(b_ptrn);\n      var a_type = this.type_of(a_addr);\n      var b_type = this.type_of(b_addr);\n      var a_kind = this.kind_of(a_addr);\n      var b_kind = this.kind_of(b_addr);\n\n      // NodeAnnihilation, UnaryAnnihilation, BinaryAnnihilation\n      if ( a_type === NOD && b_type === NOD && a_kind === b_kind\n        || a_type === OP1 && b_type === OP1\n        || a_type === OP2 && b_type === OP2\n        || a_type === ITE && b_type === ITE) {\n        var a_aux1_dest = this.enter_port(Pointer(a_addr, 1));\n        var b_aux1_dest = this.enter_port(Pointer(b_addr, 1));\n        this.link_ports(a_aux1_dest, b_aux1_dest);\n        var a_aux2_dest = this.enter_port(Pointer(a_addr, 2));\n        var b_aux2_dest = this.enter_port(Pointer(b_addr, 2));\n        this.link_ports(a_aux2_dest, b_aux2_dest);\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // NodeDuplication, BinaryDuplication\n      } else if\n        (  a_type === NOD && b_type === NOD && a_kind !== b_kind\n        || a_type === NOD && b_type === OP2\n        || a_type === NOD && b_type === ITE) {\n        var p_addr = this.alloc_node(b_type, b_kind);\n        var q_addr = this.alloc_node(b_type, b_kind);\n        var r_addr = this.alloc_node(a_type, a_kind);\n        var s_addr = this.alloc_node(a_type, a_kind);\n        this.link_ports(Pointer(r_addr, 1), Pointer(p_addr, 1));\n        this.link_ports(Pointer(s_addr, 1), Pointer(p_addr, 2));\n        this.link_ports(Pointer(r_addr, 2), Pointer(q_addr, 1));\n        this.link_ports(Pointer(s_addr, 2), Pointer(q_addr, 2));\n        this.link_ports(Pointer(p_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(Pointer(q_addr, 0), this.enter_port(Pointer(a_addr, 2)));\n        this.link_ports(Pointer(r_addr, 0), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(s_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // UnaryDuplication\n      } else if\n        (  a_type === NOD && b_type === OP1\n        || a_type === ITE && b_type === OP1) {\n        var c_addr = this.alloc_node(OP1, b_kind);\n        this.link_ports(Pointer(c_addr, 1), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(a_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        this.link_ports(this.enter_port(Pointer(a_addr, 1)), Pointer(b_addr, 0));\n        this.link_ports(this.enter_port(Pointer(a_addr, 2)), Pointer(c_addr, 0));\n        this.link_ports(Pointer(a_addr, 1), Pointer(b_addr, 2));\n        this.link_ports(Pointer(a_addr, 2), Pointer(c_addr, 2));\n      \n      // Permutations\n      } else if (a_type === OP1 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === OP2 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === ITE && b_type === NOD) {\n        return this.rewrite(b_addr);\n\n      // InvalidInteraction\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This could be performed in parallel and doesn't need GC.\n  reduce_strict(stats) {\n    var rewrites = 0;\n    var loops = 0;\n    var max_len = 0;\n    while (this.redex.length > 0) {\n      for (var i = 0, l = this.redex.length; i < l; ++i) {\n        this.rewrite(this.redex.pop());\n        stats.max_len = Math.max(stats.max_len, this.nodes.length / 4);\n        ++stats.rewrites;\n      }\n      ++stats.loops;\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This avoids unecessary computations, but is sequential and would need GC.\n  reduce_lazy(stats) {\n    this.find_redex = false;\n    var warp = [];\n    var back = [];\n    var prev = Pointer(0, 1);\n    var next = this.enter_port(prev);\n    var rwts = 0;\n    while (true) {\n      ++stats.loops;\n      if (type_of(next) === PTR && (addr_of(next) === 0 || this.is_free(addr_of(next)))) {\n        if (warp.length === 0) {\n          break;\n        } else {\n          prev = warp.pop();\n          next = this.enter_port(prev);\n        }\n      } else {\n        if (slot_of(prev) === 0 && (type_of(next) === NUM || slot_of(next) === 0)) {\n          this.rewrite(addr_of(prev));\n          stats.rewrites += 1;\n          stats.max_len = Math.max(stats.max_len, this.nodes.length / 4);\n          do { prev = back.pop(); } while (type_of(prev) !== PTR);\n          next = this.enter_port(prev);\n          ++rwts;\n        } else if (type_of(next) === NUM) {\n          [prev,next] = [next,prev];\n        } else if (slot_of(next) === 0) {\n          if (this.type_of(addr_of(next)) !== OP1) {\n            warp.push(Pointer(addr_of(next), 1));\n          }\n          prev = Pointer(addr_of(next), 2);\n          next = this.enter_port(prev);\n        } else {\n          back.push(prev);\n          prev = Pointer(addr_of(next), 0);\n          next = this.enter_port(prev);\n        }\n      }\n    }\n    this.find_redex = true;\n  }\n\n  // Returns a string that is preserved on reduction, good for debugging\n  denote(ptrn = this.enter_port(Pointer(0, 1)), exit = []) {\n    function path_to_string(path) {\n      var str = \"<\";\n      while (path) {\n        str += path.head === 1 ? \"a\" : \"b\";\n        path = path.tail; \n      }\n      str += \">\";\n      return str;\n    }\n    while (true) {\n      if (type_of(ptrn) === PTR) {\n        var ai = addr_of(ptrn);\n        var as = slot_of(ptrn)\n        var ak = this.kind_of(ai);\n        switch (this.type_of(ai)) {\n          case NOD:\n            if (slot_of(ptrn) === 0) {\n              if (exit[ak]) {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = new_exit[ak].tail;\n                ptrn = this.enter_port(Pointer(ai, Number(exit[ak].head)));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              } else {\n                var lft = this.denote(this.enter_port(Pointer(ai, 1)), exit);\n                var rgt = this.denote(this.enter_port(Pointer(ai, 2)), exit);\n                return \"(\" + ak + \" \" + lft + \" \" + rgt + \")\";\n              }\n            } else {\n              if (ai === 0) {\n                while (exit[exit.length - 1] === null) exit.pop();\n                return exit.map(path_to_string).join(\":\");\n              } else {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = {head: as, tail: new_exit[ak] || null};\n                ptrn = this.enter_port(Pointer(ai, 0));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              }\n            }\n            break;\n          default:\n            return \"<TODO>\";\n        }\n      } else {\n        return \"#\" + numb_of(ptrn);\n      }\n    }\n  }\n\n  to_string() {\n    const pointer = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return \"#\" + numb_of(ptrn);\n      } else {\n        return addr_of(ptrn) + \"abc\"[slot_of(ptrn)];\n      }\n    };\n    var text = '';\n    for (var i = 0; i < this.nodes.length / 4; i++) {\n      if (this.is_free(i)) {\n        text += i + \": ~\\n\";\n      } else {\n        var type = this.type_of(i);\n        var kind = this.kind_of(i);\n        text += i + ': ';\n        text += \"[\" + type + \":\" + kind + \"| \";\n        text += pointer(this.get_port(i, 0)) + \" \";\n        text += pointer(this.get_port(i, 1)) + \" \";\n        text += pointer(this.get_port(i, 2)) + \"]\";\n        text += \"...\" + this.is_numeric(i,0) + \" \" + this.is_numeric(i,1) + \" \" + this.is_numeric(i,2);\n        text += \"\\n\";\n      }\n    }\n    return text;\n  }\n}\n\nmodule.exports = {Pointer, addr_of, slot_of, Numeric, numb_of, type_of, Net, NUM, PTR, NOD, OP1, OP2, ITE};\n\n\n//# sourceURL=webpack:///./node_modules/formality-net/fm-net.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// ::::::::::\n// :: Game ::\n// ::::::::::\n\nconst fm = __webpack_require__(/*! formality-core */ \"./node_modules/formality-core/exports.js\");\nconst {infs, defs} = fm.core.parse(__webpack_require__(/*! ./../../formality-core/examples */ \"../formality-core/examples/_export_to_webpack_.js\"));\nconst compile = name => fm.to_js.compile(defs[name], defs);\nconst K = {\n  new_board: compile(\"new_board\"),\n  step: compile(\"step\")\n};\n\n// :::::::::::::::\n// :: Rendering ::\n// :::::::::::::::\n\n// FPS meter\nconst fps = (function fps() {\n  var fps = 0;\n  var frames = 0;\n  var last = Date.now() / 1000;\n  return function frame() {\n    ++frames;\n    if (Date.now() / 1000 - last > 1) {\n      fps = frames;\n      console.log(\"fps:\" + fps);\n      frames = 0;\n      last = Date.now() / 1000;\n    }\n  };\n})();\n\n// Keyboard\nconst Keyboard = (callbacks) => {\n  callbacks.down = callbacks.down || function(){};\n  callbacks.up = callbacks.up || function(){};\n  var key = {};\n  document.addEventListener(\"keydown\", e => { key[e.key] = 1; callbacks.down(e.key); });\n  document.addEventListener(\"keyup\", e => { key[e.key] = 0; callbacks.up(e.key); });\n  return key;\n};\n\n// Image\nconst Image = (src, offset, flip) => {\n  var image = document.createElement(\"img\");\n  image.src = \"img/\" + src;\n  image.onload = () => {\n    if (flip) offset[0] = - offset[0];\n    offset[0] -= image.width * 0.5;\n    offset[1] -= image.height * 0.5;\n  };\n  image.offset = offset;\n  return image;\n};\n\n// Images\nconst images = {\n  thief: {\n    right: [\n      Image(\"thief/frame_00r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_01r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_02r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_03r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_04r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_05r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_06r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_07r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_08r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_09r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_10r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_11r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_12r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_13r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_14r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_15r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_16r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_17r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_18r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_19r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_20r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_21r.gif\", [-28,-16], 1),\n      Image(\"thief/frame_22r.gif\", [-28,-16], 1),\n    ],\n    left: [\n      Image(\"thief/frame_00.gif\", [-28,-16], 0),\n      Image(\"thief/frame_01.gif\", [-28,-16], 0),\n      Image(\"thief/frame_02.gif\", [-28,-16], 0),\n      Image(\"thief/frame_03.gif\", [-28,-16], 0),\n      Image(\"thief/frame_04.gif\", [-28,-16], 0),\n      Image(\"thief/frame_05.gif\", [-28,-16], 0),\n      Image(\"thief/frame_06.gif\", [-28,-16], 0),\n      Image(\"thief/frame_07.gif\", [-28,-16], 0),\n      Image(\"thief/frame_08.gif\", [-28,-16], 0),\n      Image(\"thief/frame_09.gif\", [-28,-16], 0),\n      Image(\"thief/frame_10.gif\", [-28,-16], 0),\n      Image(\"thief/frame_11.gif\", [-28,-16], 0),\n      Image(\"thief/frame_12.gif\", [-28,-16], 0),\n      Image(\"thief/frame_13.gif\", [-28,-16], 0),\n      Image(\"thief/frame_14.gif\", [-28,-16], 0),\n      Image(\"thief/frame_15.gif\", [-28,-16], 0),\n      Image(\"thief/frame_16.gif\", [-28,-16], 0),\n      Image(\"thief/frame_17.gif\", [-28,-16], 0),\n      Image(\"thief/frame_18.gif\", [-28,-16], 0),\n      Image(\"thief/frame_19.gif\", [-28,-16], 0),\n      Image(\"thief/frame_20.gif\", [-28,-16], 0),\n      Image(\"thief/frame_21.gif\", [-28,-16], 0),\n      Image(\"thief/frame_22.gif\", [-28,-16], 0),\n    ],\n  }\n};\n\n// Creates a new canvas\nfunction Canvas(width, height) {\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  canvas.style.margin = \"0px\";\n  canvas.style.padding = \"0px\";\n\n  var context = canvas.getContext(\"2d\");\n  context.imageSmoothingEnabled = false;\n  context.font = \"10px Arial\";\n  context.textBaseline = \"middle\"; \n  context.textAlign = \"center\";\n\n  canvas.context = context;\n\n  return canvas;\n};\n\n// Renders the board to a canvas\nconst render_board = (game_board, canvas) => {\n  // Utils\n  const tile_size = 24;\n  const pos_to_coord = ([i,j]) => [i * tile_size, j * tile_size];\n\n  // Converts board to JSON\n  const piece_to_json = val => {\n    let case_air    = [\"Air\"];\n    let case_wall   = [\"Wall\"];\n    let case_cliff  = [\"Cliff\"];\n    let case_throne = side => [\"Throne\", {side}];\n    let case_unit   = side => hero => hp => [\"Unit\", {side, hero, hp}];\n    return val(case_air)(case_wall)(case_cliff)(case_throne)(case_unit);\n  };\n  const board_to_json = (val, i = 0) => {\n    if (i < 10) {\n      return board_to_json(val[0], i + 1).concat(board_to_json(val[1], i + 1));\n    } else {\n      return [piece_to_json(val)];\n    }\n  };\n  const board = board_to_json(game_board);\n\n  // Clears\n  canvas.context.clearRect(0, 0, canvas.width, canvas.height);\n\n  // Draws grid\n  for (var j = 0; j < 32; ++j) {\n    for (var i = 0; i < 32; ++i) {\n      var [x,y] = pos_to_coord([i,j]);\n      canvas.context.strokeStyle = \"rgba(128,128,128,0.15)\";\n      canvas.context.beginPath();\n      canvas.context.rect(x, y, tile_size, tile_size);\n      canvas.context.stroke();\n      canvas.context.closePath();\n    }\n  }\n\n  // Draws pieces\n  for (var j = 0; j < 32; ++j) {\n    for (var i = 0; i < 32; ++i) {\n      var [x,y] = pos_to_coord([i,j]);\n      var piece = board[j * 32 + i];\n      switch (piece[0]) {\n        case \"Air\":\n          break;\n        case \"Wall\":\n          canvas.context.fillStyle = \"rgb(64,64,64)\";\n          canvas.context.beginPath();\n          canvas.context.rect(x, y, tile_size, tile_size);\n          canvas.context.fill();\n          canvas.context.closePath();\n          break;\n        case \"Cliff\":\n          canvas.context.fillStyle = \"rgb(64,128,64)\";\n          canvas.context.beginPath();\n          canvas.context.rect(x, y, tile_size, tile_size);\n          canvas.context.fill();\n          canvas.context.closePath();\n          break;\n        case \"Throne\":\n          canvas.context.fillStyle = \"rgb(128,64,64)\";\n          canvas.context.beginPath();\n          canvas.context.rect(x, y, tile_size, tile_size);\n          canvas.context.fill();\n          canvas.context.closePath();\n          break;\n        case \"Unit\":\n          if (piece[1].side === 0) {\n            canvas.context.fillStyle = \"rgb(128,128,256)\";\n            canvas.context.beginPath();\n            canvas.context.rect(x, y, tile_size, tile_size);\n            canvas.context.fill();\n            canvas.context.closePath();\n          } else {\n            canvas.context.fillStyle = \"rgb(256,128,128)\";\n            canvas.context.beginPath();\n            canvas.context.rect(x, y, tile_size, tile_size);\n            canvas.context.fill();\n            canvas.context.closePath();\n          }\n          break;\n      }\n    }\n  }\n};\n\nwindow.onload = () => {\n  // Name\n  if (!localStorage.getItem(\"name\")) {\n    localStorage.setItem(\"name\", prompt(\"Your name:\"));\n  }\n  var name = localStorage.getItem(\"name\");\n\n  // State\n  var game = null;\n\n  // Messages\n  let msgs = [];\n  const new_msg = (data) => {\n    var player = data.slice(0, data.indexOf(\":\"));\n    var msg = data.slice(data.indexOf(\":\") + 2);\n\n    // Performs command\n    if (msg[0] === \"/\") {\n      var cmd = msg.slice(1, msg.indexOf(\" \"));\n      var arg = msg.slice(msg.indexOf(\" \") + 1).split(\" \");\n      switch (cmd) {\n        case \"new\":\n          game = {\n            players: arg,\n            board: K.new_board\n          }\n        break;\n        case \"step\":\n          const pos = JSON.parse(arg[0]);\n          const dir = JSON.parse(arg[1]);\n          game.board = K.step(pos)(dir)(game.board);\n        break;\n      }\n    };\n\n    // Adds to interface\n    var msg_el = document.createElement(\"div\");\n    msg_el.className = \"message\";\n    msg_el.innerText = player + \": \" + msg;\n    chat.appendChild(msg_el);\n  }\n\n  // Connection\n  const ws = new WebSocket(\"ws://\" + location.host + \"/chat\");\n  ws.onopen = function open() {};\n  ws.onmessage = (data) => new_msg(data.data);\n\n  // Canvas\n  var canvas = Canvas(24 * 32, 24 * 32);\n  document.getElementById(\"board_box\").appendChild(canvas);\n\n  // Chat\n  var chat = document.createElement(\"div\");\n  var chat_box = document.getElementById(\"chat_box\");\n  var input = document.getElementById(\"input\");\n  chat.style.width = \"100%\";\n  chat.style.height = \"100%\";\n  chat_box.appendChild(chat);\n  input.onkeypress = function(e) {\n    if (e.key === \"Enter\") {\n      ws.send(name + \": \" + input.value);\n      setTimeout(() => {\n        input.value = \"\";\n        chat_box.scrollTop = chat_box.scrollHeight;\n      }, 0);\n    }\n  };\n\n  // Main loop\n  const render = () => {\n    if (game) {\n      render_board(game.board, canvas); \n    }\n    window.requestAnimationFrame(render);\n  };\n\n  window.requestAnimationFrame(render);\n};\n\n\n// Draws tiles\n//for (var j = 0; j < game.dim[1]; ++j) {\n  //for (var i = 0; i < game.dim[0]; ++i) { \n    //var [x,y] = pos_to_coord([i, j]);\n    //var thing = get_thing(game, [i,j]);\n    //var floor = get_floor(game, [i,j]);\n\n    //// Thing\n    //if (thing && thing.color) {\n      //if (thing.pid !== null) {\n        ////var [x,y] = project(walk_anim_pos(thing, [i,j]));\n        //var frame = T - thing.last_attack < 1.375 ? Math.floor(((T - thing.last_attack) * 16) % 22) : 0;\n        //var image = images.thief[thing.face][frame];\n        //canvas.context.drawImage(image, x + image.offset[0] + tile_size * 0.5, y + image.offset[1] + tile_size * 0.5);\n      //} else {\n        //canvas.context.fillStyle = thing.color;\n        //canvas.context.beginPath();\n        //canvas.context.rect(x, y, tile_size, tile_size);\n        //canvas.context.fill();\n        //canvas.context.closePath();\n      //}\n    //}\n  //}\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });